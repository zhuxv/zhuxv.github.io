{"meta":{"title":"小朱的技术博客","subtitle":"","description":"","author":"Zhu Xv","url":"https://zhuxv.github.io","root":"/"},"pages":[{"title":"","date":"2020-09-27T08:48:48.507Z","updated":"2020-09-27T08:48:48.399Z","comments":true,"path":"about/index.html","permalink":"https://zhuxv.github.io/about/index.html","excerpt":"","text":"关于我从事 WEB 开发，主要开发语言 PHP，熟悉使用 Laravel、ThinkPHP 等主流框架； 对服务端、前端、服务器 相关技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：上海 关于学习正在往终身学习者前进…近期学习方向：Linux(服务器, 运行环境) 关于座右铭 深林几处啼鹃, 梦如烟 关于爱好热爱运动，游戏，尤其喜爱阅读、电影、旅行。 联系我 Home: zhuxv.com Blog: zhuxv.github.io Email: &#49;&#48;&#x37;&#49;&#x37;&#x38;&#54;&#50;&#x30;&#52;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d; GitHub: ZhuXv WeiBo: Twitter:"}],"posts":[{"title":"常见的几种WEB攻击-DDOS","slug":"常见的几种WEB攻击-DDOS","date":"2020-10-15T01:54:47.000Z","updated":"2020-10-15T03:58:14.534Z","comments":true,"path":"2020/10/15/常见的几种WEB攻击-DDOS/","link":"","permalink":"https://zhuxv.github.io/2020/10/15/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8DWEB%E6%94%BB%E5%87%BB-DDOS/","excerpt":"DDOS什么是DDOS全称 Distributed Denial of Service, 中文意思为 “分布式拒绝服务”, 就是利用大量合法的分布式服务器对目标发送请求, 从而导致正常合法用户无法获得服务. 通俗点讲就是利用网络节点资源如: IDC服务器, 个人PC, 手机, 智能设备, 打印机, 摄像头等对目标发起大量攻击请求, 从而导致服务器拥塞而无法对外提供正常服务","text":"DDOS什么是DDOS全称 Distributed Denial of Service, 中文意思为 “分布式拒绝服务”, 就是利用大量合法的分布式服务器对目标发送请求, 从而导致正常合法用户无法获得服务. 通俗点讲就是利用网络节点资源如: IDC服务器, 个人PC, 手机, 智能设备, 打印机, 摄像头等对目标发起大量攻击请求, 从而导致服务器拥塞而无法对外提供正常服务 黑客为什么选择DDOS不同于其他恶意篡改数据或劫持类攻击, DDoS 简单粗暴, 可以达到直接摧毁目标的目的. 另外, 相对其他攻击手段 DDoS 的技术要求和发动攻击的成本很低, 只需要够买部分服务器权限或控制一批肉鸡即可, 而且攻击相应速度很快, 攻击效果可视. 另一方面, DDoS 具有攻击易防守难的特征, 服务提供商为了保证正常客户的需求需要耗费大量的资源才能和攻击发起方进行对抗. 这些特点使得 DDoS 成为黑客们手中的一把很好使的利剑.从另一方面, DDoS 虽然可以侵蚀宽带或资源, 迫使服务中断, 但这远远不是黑客的真正目的. 所谓没有买卖就没有杀害, DDoS 只是黑客手中的一枚核武器, 他们的目的要么是敲诈勒索, 要么是商业竞争, 要么就是表达政治立场, 在这种黑色利益的驱使下, 越来越多的人参与到这个行业并对攻击手段进行改进升级, 致使 DDoS 在互联网行业愈演愈烈, 并成为全球范围内无法攻克的一个顽疾 DDoS的攻击方式资源消耗类攻击资源消耗类是比较典型的 DDoS 攻击, 最具代表性的包括: Syn Flood, Ack Flood, UDP Flood. 这类攻击的目标简单, 就是通过大量请求消耗正常的宽带和协议栈处理资源的能力, 从而达到服务端无法正常工作的目的. 服务消耗性攻击相比资源消耗类攻击, 服务消耗类攻击不需要太大的流量, 他主要是针对服务的特点进行精确定点打击, 如 WEB 的 CC, 数据服务的检索, 文件服务的下载等. 这类攻击往往不是为了拥塞流量通道或协议处理通道, 他们是让服务端始终处理高消耗型的业务的忙碌状态, 进而无法对正常业务进行响应 反射类攻击反射攻击也叫放大攻击, 该类攻击以 UDP 协议为主, 一般请求回应的流量远远大于请求本身流量的大小. 攻击者通过流量被放大的特点以较小的流量宽带就可以制造出大规模的流量源, 从而对目标发起攻击. 反射类攻击严格意义上来说不算是攻击的一种, 他只是利用某些服务的业务特征来实现用更小的代价发动 Flood 攻击 混合型攻击混合型攻击是结合上述几种攻击类型, 并在攻击过程中进行探测选择最佳的攻击方式. 混合型攻击往往伴随这资源消耗和服务消耗两种的攻击特征 DDoS防护困难一方面在过去的几十年中, 网络基础设施核心部件从未改变, 这使得一些已经发现和被利用的漏洞以及一些成熟的攻击工具生命周期很长, 即使放到今天也依然有效. 另一方面, 互联网七层模型应用的迅猛发展, 使得 DDoS 的攻击目标多元化, 从 web 到 DNS, 从三层网络到七层应用, 从协议栈到应用 App, 层出不穷的新产品也给了黑客更多的机会和突破点. 在者 DDoS 的防护是一个技术和成本不对等的工程, 往往一个业务的 DDoS 防御系统建设成本要比业务本身的成本或收益更加庞大, 这使得很多创业公司或小型互联网公司不愿意做更多的投入. DDoS防护手段资源隔离资源隔离可以看做是用户服务的一堵防护盾, 这套防护系统拥有无比强大的数据和流量处理能力, 为用户过滤异常流量和请求. 如: 针对 Syn Flood, 防护盾会响应 Syn Cookie 或 Syn Reset 认证, 通过对数据源的认证, 过滤伪造源数据包或发动的攻击, 保护服务端不受恶意连接的侵蚀. 资源隔离系统主要是针对 ISO 模型的第三层和第四层进行防护 用户规则从服务的角度来说 DDoS 防护本质上是一场已用户为主体依赖抗D防护系统与黑客进行较量的战争, 在整个数据对抗过程中服务提供者往往具有绝对的主动权, 用户可以基于抗D系统特定的规则, 如: 流量类型, 请求频率, 数据包特征, 正常业务之间的延长时间间隔等. 基于这些规则用户可以再满足正常服务本身的前提下更好的对抗七层类的 DDoS, 并减少服务端的资源开销 大数据智能分析黑客为了构造大量的数据流, 往往需要通过特定的工具来构造请求数据, 这些数据包不具有正常用户的一些行为特征. 为了对抗这种攻击, 可以基于对海量数据进行分析, 进而对合法用户进行模型化, 并利用这些指纹特征, 如: HTTP 模型特征, 数据来源, 请求源等, 有效的对请求源进行白名单过滤, 从而实现对 DDoS 流量的精确清洗 资源对抗资源对抗也叫 “死扛”, 即通过大量服务器和宽带资源的堆砌达到从容应对 DDoS 流量的效果 参考博文[1] 什么是DDOS攻击","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://zhuxv.github.io/categories/WEB%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://zhuxv.github.io/tags/WEB/"},{"name":"安全","slug":"安全","permalink":"https://zhuxv.github.io/tags/%E5%AE%89%E5%85%A8/"},{"name":"DDOS","slug":"DDOS","permalink":"https://zhuxv.github.io/tags/DDOS/"}],"author":"Zhu Xv"},{"title":"常见的几种WEB攻击-SQL注入","slug":"常见的几种WEB攻击-SQL注入","date":"2020-09-29T09:43:26.000Z","updated":"2020-10-15T02:54:38.606Z","comments":true,"path":"2020/09/29/常见的几种WEB攻击-SQL注入/","link":"","permalink":"https://zhuxv.github.io/2020/09/29/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8DWEB%E6%94%BB%E5%87%BB-SQL%E6%B3%A8%E5%85%A5/","excerpt":"SQL注入什么是SQL注入SQL 注入是通过客户端的输入把 SQL 命令注入到一个应用的数据库中, 从而执行恶意的 SQL 语句.","text":"SQL注入什么是SQL注入SQL 注入是通过客户端的输入把 SQL 命令注入到一个应用的数据库中, 从而执行恶意的 SQL 语句. SQL 被攻击的原因是: sql 语句伪造参数, 然后对参数进行拼接后形成 xss 攻击的 sql 语句. 最后导致数据库被攻击了 注意: 但凡有 SQL 注入漏洞的程序, 都是因为程序要接受来自客户端用户输入的变量或 URL 传递的参数, 并且这个变量或参数是组成 SQL 语句的一部分, 对于用户输入的内容或传递的参数, 我们应该要时刻保持警惕, 这里安全领域里的 [外部数据不可信任] 的原则, 纵观 WEB 安全领域的各种攻击方式, 大多数都是因为开发者违反了这个原则而导致的, 所以自然能想到的, 就是从变量的检测, 过滤, 验证下手, 确保变量是开发者所预想的 防范方法: 我们可以使用预编译语句(PreparedStatement), 这样的话即使我们使用 sql 语句伪造参数, 到了服务端的时候, 这个伪造 sql 语句的参数也只是简单的字符串, 并不能起到攻击的作用数据库中的密码不明文存储, 可以对密码进行 md5 加密, 为了加大破解成本, 可以采用加盐的方式只要有固定格式的变量, 在 SQL 语句执行前, 应该严格按照固定格式去检查, 确保变量是我们预想的格式, 这样可以很大程度上避免 SQL 注入 什么是预编译通常我们的一条 SQL 在 db 接收到最终执行完毕返回可以分为下面三个过程 词法和语义解析 优化 sql 语句, 制定执行计划 执行并返回结果 我们把 这种普通语句称作 Immediate Statements.但是很多情况下, 我们的一条 sql 语句可能会反复执行, 或者每次执行的时候只有个别的值不同.如果每次都需要经过上面的词法语义解析, 语句优化, 指定执行计划, 则效率明显就不行了.所谓预编译语句就是将这类语句中的值用占位符代替, 可以视为将 sql 语句模板化或者参数化, 一般称这类语句叫 Prepared Statements 或者 Parameterized Statements预编译语句优势在于: 一次编译, 多次运行, 省去了解析优化等过程; 此外预编译能够防止 sql 注入 防止SQL注入 永远不要信任用户的输入, 对用户的输入进行校验, 可以通过正则表达式, 或限制长度; 对单双引号进行转换 永远不要使用动态拼接 SQL, 可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取 永远不要使用管理员权限的数据库连接, 为每个应用使用单独的权限有限的数据库连接 不要把机密信息直接存放, 加密或者 hash 掉密码和敏感信息 应用的异常信息应该给出尽可能少的提示, 最好使用自定义的错误信息对原始错误信息进行包装 PHP 在MySQL 扩展提供了 mysqli_real_escape_string() 函数来转义特殊的输入字符, addcslashes() 函数在指定字符前增加反斜杠 参考博文[1] MySQL及SQL注入","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://zhuxv.github.io/categories/WEB%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://zhuxv.github.io/tags/WEB/"},{"name":"安全","slug":"安全","permalink":"https://zhuxv.github.io/tags/%E5%AE%89%E5%85%A8/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://zhuxv.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}],"author":"Zhu Xv"},{"title":"常见的几种WEB攻击-XSS","slug":"常见的几种WEB攻击-XSS","date":"2020-09-29T09:43:26.000Z","updated":"2020-10-15T02:09:52.963Z","comments":true,"path":"2020/09/29/常见的几种WEB攻击-XSS/","link":"","permalink":"https://zhuxv.github.io/2020/09/29/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8DWEB%E6%94%BB%E5%87%BB-XSS/","excerpt":"搞Web开发离不开安全这个话题，确保网站或者网页应用的安全性，是每个开发人员都应该了解的事。","text":"搞Web开发离不开安全这个话题，确保网站或者网页应用的安全性，是每个开发人员都应该了解的事。 XSS攻击什么是XSS攻击XSS 即(Cross Site Scripting) 中文名称为: 跨站脚本攻击 XSS的重点不在于跨站点, 而在于脚本的执行. 那么XSS的原理是:恶意攻击者在 web 页面中会插入一些恶意的 script 代码. 当用户浏览该网页的时候, name嵌入到 web 页面中 script 代码会执行, 因此会达到恶意攻击的目的. 那么 XSS 攻击最主要有如下分类: 反射型, 存储型以及 DOM-based 型. 反射型和 DOM-based 型可以归类为非持久性 XSS 攻击. 存储型可以归类为持久性 XSS 攻击 cookie 安全策略在服务器端设置 cookie 的时候设置 http-only, 这样就可以防止用户通过 JS 获取 cookie设置: http-only: 只允许 http 或 https 请求读取 cookie, JS 代码是无法读取 cookie 的. 发送请求时自动发送 cookie.secure-only: 只允许 https 请求读取, 发送请求时自动发送 cookiehost-only: 只允许主机域名与 domain 设置完成一致的网站才能访问该 cookie X-XSS-Protection 设置目前该属性被所有的主流浏览器默认开启 XSS 保护. 该参数是设置在响应头中目的是用来防范 XSS 攻击的. 他有如下几种配置: 默认为 1. 0: 禁用 XSS 保护1: 启用 XSS 保护1; mode=block; 启用 XSS 保护, 并且在检查到 XSS 攻击时, 停止页面渲染 XSS 防御 HTML 编码我们需要将不可信数据放入到 html 标签内的时候需要进行 html 编码编码规则: 将 &amp;&lt;&gt;”‘/ 转义为实体字符. XSS 防御 HTML Attribute 编码和 HTML 编码一样, html 中的属性也要进行编码, 比如 &lt;input name=&quot;name&quot; /&gt;, name 是 input 的属性, 因此在 html 解析时, 会对 name 属性进行编码, 因为假如 {name} 的值为: &quot; onclick=&quot;alert(&#39;属性XSS&#39;)&quot; &quot;这样的, input 就变成了: &lt;input name=&quot;&quot; onclick=&quot;alert(&#39;属性XSS&#39;)&quot; &quot;&quot; /&gt;. input 属性 name 被插入了 onclick 事件, 因此对于常规的 html 属性, 都需要对其进行 HTML 属性编码.编码规则: 除了字母, 数字, 字符以外, 使用 &#x;16进制格式来转义 ASCII 值小于 256 以外的所有字符 javascript 编码在上面的 XSS 防御 HTML Attribute 编码中我们是可以防御 XSS 攻击, 但是他只能防御的是 HTML 的通用属性, 并不是全部属性, 在 html 中还存在很多支持协议解析的 html 属性, 比如 onclick, onerror, href, src 等这些, 类似这些属性我们是无法通过 HTML 编码来防范 XSS 攻击的. 因为浏览器会先解析 html 编码的字符, 将其转换为该属性的值, 但是该属性本身支持 JS 代码执行, 因此浏览器在 HTML 解码后, 对该属性的值进行 JS 解析, 因此会执行响应的代码.JavaScript 编码将字符编码成 \\x+16 进制的形式, 对字节编码成 Unicode URL 编码作用范围: 将不可信数据作为 URL 参数值时需要对参数进行 URL 编码编码规则: 将参数值进行 encodeURLComponent 编码 CSS 编码作用范围: 将不可信数据作为 CSS 时进行 CSS 编码编码规则: 除了数字字母字符以外, 使用 \\XXXXXX 格式来转义 ASCII 值小于 256 的所有字符. 开启 CSP 网页安全政策防止 XSS 攻击Content-Security-Policy 中文的意思是 网页安全策略, CSP 是网络安全策略的缩写. 主要用来防止 XSS 攻击. 是一种由开发者定义的安全性政策申明, 通过 CSP 所约束的责任指定可信的内容来源, 通过 Content-Security-Policy 网页的开发者可以控制整个页面中 外部资源 的加载和执行.比如可以控制哪些域名下的静态资源可以被页面加载, 哪些不能被加载. 这样就可以很大程度的防范了来自跨站的脚本攻击使用方法: 12345&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot; default-src http: https: *.xxx.com &#x27;self&#x27; &#x27;unsafe-inline&#x27; ; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; *.yyy.com; script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;unsafe-eval&#x27; ;&quot;&gt; 有如下类别: default-src 给下面所有的规则设定一个默认值script-src 外部脚本: unsafe-inline 允许执行页面的内嵌的 &lt;script&gt; 标签和事件监听函数 unsafe-eval 允许将字符串当做代码执行, 比如使用 eval, setTimeout, setInterval 和 Function 函数 nonce 每次 HTTP 回应给出一个授权 token, 页面内嵌脚本必须有 token, 才会执行 hash 列出允许执行的脚本代码的 HASH 值, 页面内嵌脚本的哈希值只有吻合的情况下, 才能执行style-src 样式表img-src 图像media-src 媒体文件font-src 字体文件object-src 插件(如: Flash)child-src 框架frame-ancestors 嵌入外部资源, 比如, connect-src HTTP连接 (通过 XHR, WebSockets, EventSource 等)worker-src worker脚本manifest-src manifest文件 参考博文[1] web安全之XSS攻击原理及防范","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://zhuxv.github.io/categories/WEB%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://zhuxv.github.io/tags/WEB/"},{"name":"安全","slug":"安全","permalink":"https://zhuxv.github.io/tags/%E5%AE%89%E5%85%A8/"},{"name":"XSS","slug":"XSS","permalink":"https://zhuxv.github.io/tags/XSS/"}],"author":"Zhu Xv"},{"title":"RESTfulAPI的理解及其原理","slug":"RESTfulAPI的理解及其原理","date":"2020-09-29T08:52:55.000Z","updated":"2020-10-15T05:48:49.390Z","comments":true,"path":"2020/09/29/RESTfulAPI的理解及其原理/","link":"","permalink":"https://zhuxv.github.io/2020/09/29/RESTfulAPI%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/","excerpt":"RESTful架构, 就是目前最流行的一种互联网软件架构. 他结构清晰, 符合标准, 易于理解, 扩展方便, 所以正得到越来越多的网站采用","text":"RESTful架构, 就是目前最流行的一种互联网软件架构. 他结构清晰, 符合标准, 易于理解, 扩展方便, 所以正得到越来越多的网站采用 RESTful API 的理解及其原理REST, 即 Representational State Transfer 的缩写. 我对这个词组的翻译是 “表现层状态转化”.如果一个架构符合 REST 原则, 就称他为 RESTful 架构 资源(Resources)REST的名称 表现层状态转化 中, 省略了主语. 表现层 其实指的就是 资源 Resources 的 表现层所谓 资源, 就是网络上的一个实体, 或者说是网络上的一个具体信息. 他可以是一段文本, 一张图片, 一首歌曲, 一种服务, 总之就是一个具体的实在. 你可以用一个 URI 统一资源定位符 指向他, 每种资源对应一个特定的 URI. 要获取这个资源, 访问他的 URI 就可以, 因此 URI 就成了每个资源的地址或独一无二的标识符所谓 上网, 就是与互联网上一系列的 资源 互动, 调用他的 URI 表现层(Representation)资源 是一种信息实体, 他可以有多种外在表现形式. 我们把 资源 具体呈现出来的形式, 叫做他的 表现层 Representation比如: 文本可以用 txt 格式表现, 也可以用 HTML 格式, XML 格式, JSON 格式表现, 甚至可以采用二进制格式; 图片可以用 JPG 格式表现, 也可以用 PNG 格式表现.URL 只代表资源的实体, 不代表他的形式. 严格的说, 有些网址最后的 “.html” 后缀名是不必要的, 因为这个后缀表示格式, 属于 表现层 的范畴, 而 URI 应该只代表 资源 的位置. 他的具体表现形式, 应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定, 这两个字段才是对 表现层 的描述. 状态转化(State Transfer)访问一个网站, 就代表了客户端和服务器的一个互动过程. 在这个过程中, 势必涉及到数据和状态的变化.互联网通信协议 HTTP 协议, 是一个无状态协议. 这意味着, 所有的状态都保存在服务器端. 因此, 如果客户端想要操作服务器, 必须通过某种手段, 让服务端发生 状态转化 State Transfer. 而这种转化是建立在表现层之上的, 所以就是 表现层状态转化.客户端用到的手段, 只是 HTTP 协议. 具体来说, 就是 HTTP 协议里面, 四个表示操作方式的动词: GET, POST, PUT, DELETE. 他们分别对应四种基本操作: GET 用来获取资源, POST 用来新建资源, PUT 用来更新资源, DELETE 用来删除资源. 综述综合上面的解释, 我们总结一下什么是 RESTful 架构: (1) 每一个 URI 代表一种资源;(2) 客户端和服务端之间, 传递这种资源的某种表现层;(3) 客户端通过四个 HTTP 动词, 对服务端资源进行操作, 实现 表现层状态转化. 误区最常见的一种设计错误, 就是 URI 包含动词. 因为 资源 表示一种实体, 所以应该是名词, URI 不应该有动词, 动词应该放在 HTTP 协议中.另一种设计误区, 就是在 URI 中加入版本号. 因为不同的版本, 可以理解成同一种资源的不同表现形式, 所以应该采用同一个 URI. 版本号可以在 HTTP 请求头信息的 Accept 字段中进行区分 参考博文[1] 理解RESTful架构","categories":[{"name":"架构","slug":"架构","permalink":"https://zhuxv.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"架构","slug":"架构","permalink":"https://zhuxv.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"RESTful","slug":"RESTful","permalink":"https://zhuxv.github.io/tags/RESTful/"}],"author":"Zhu Xv"},{"title":"MVC模式","slug":"MVC模式","date":"2020-09-29T08:22:44.000Z","updated":"2020-09-29T09:03:54.090Z","comments":true,"path":"2020/09/29/MVC模式/","link":"","permalink":"https://zhuxv.github.io/2020/09/29/MVC%E6%A8%A1%E5%BC%8F/","excerpt":"如何设计一个程序的结构, 这是一门专门的学问, 叫做架构模式, 属于编程的方法论.MVC 模式就是架构模式的一种","text":"如何设计一个程序的结构, 这是一门专门的学问, 叫做架构模式, 属于编程的方法论.MVC 模式就是架构模式的一种 MVC是三个单词的首字母缩写, 他们是 Model(模型), View(视图)和Controller(控制器)这个模式认为, 程序不论简单或复杂, 从结构上看, 都可以分为三层: 1) 最上面的一层, 是直接面向最终用户的视图层(View). 他是提供给用户的操作界面, 是程序的外壳 2) 最底下的一层, 是核心的数据层(Model). 也就是程序需要操作的数据或信息 3) 中间的一层, 就是控制层(Controller), 他是根据用户从视图层输入的指令, 选取数据层中的数据, 然后对其进行相应的操作, 产生最终的结果这三层是紧密联系在一起的, 但又是相互独立的, 每一层内部的变化不影响其它层. 每一层都对外提供接口(Interface), 供上面一层调用. 这样一来, 软件就可以实现模块化, 修改外观或者变更数据都不用修改其它层, 大大方便了维护和升级 参考博文[1] 谈谈MVC模式","categories":[{"name":"MVC","slug":"MVC","permalink":"https://zhuxv.github.io/categories/MVC/"}],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://zhuxv.github.io/tags/MVC/"}],"author":"Zhu Xv"},{"title":"PHP练习题-REDIS篇","slug":"PHP练习题-REDIS篇","date":"2020-09-27T08:16:51.000Z","updated":"2020-09-27T10:14:55.127Z","comments":true,"path":"2020/09/27/PHP练习题-REDIS篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/27/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-REDIS%E7%AF%87/","excerpt":"REDIS篇REDIS 练习笔记","text":"REDIS篇REDIS 练习笔记 1.redis和memcached相比有哪些优势memcached 所有的值均是简单的字符串, redis 做为其代替者, 支持更丰富的数据类型 redis 的速度比 memcached 快很多 redis 可以持久化其数据 2.redis是单线程redis 利用队列技术将并发访问变成串行访问, 消除了传统数据库串行控制的开销 3.redis的五种数据类型string, list, set, sorted set, hash 4.redis的并发竞争问题如何解决单线程单进程模式, 采用队列模式将并发访问改为串行访问. redis 本身没有锁的概念, redis 对于多个客户端连接不存在竞争, 利用 setnx 实现锁 5.redis启动命令./redis-server 6.redis 支持的语言Java, C, C#, C++, PHP, Node.js GO 等 7.redis 持久化解决方案RDB RDB 持久化是把当前进程数据生成快照保存到硬盘的过程, 触发 RDB 持久化过程分为手动触发和自动触发 RDB 完成后会自动生成一个文件, 保存在 dir 配置的指定目录下, 文件名是 dbfilename 指定 REDIS 默认会采用 LZF 算法对生成的 RDB 文件做压缩处理, 压缩后的文件远远小于内存大小, 默认开启 手动触发: 手动触发的命令有 save 和 bgsave save: 该命令会阻塞 Redis 服务器, 直到 RDB 的过程完成, 已经被废弃, 因此线上不建议使用 bgsave: 每次进行 RDB 过程都会 fork 一个子进程, 由子进程完成 RDB 操作, 因此阻塞只会发生在 fork 阶段, 一般时间很短 自动触发: (1) 根据我们的 save m n 配置规则自动触发 (2) 如果从节点执行全量复制操作, 主节点自动执行 bgsave 生成 RDB 文件并发送给从节点 (3) 执行 debug reload 命令重新加载 Redis 时, 也会触发 save 操作 (4) 默认情况下执行 shutdown 命令时, 如果没有开启 AOF 持久化功能则自动执行 bgsave 优点: RDB 是一个紧凑的压缩的二进制文件, 代表 Redis 在某个时间点上的数据快照. 非常适用与备份, 全量复制等场景. 比如每六个小时执行 bgsave 备份, 并把 RDB 文件拷贝到远程机器或者文件系统中, 用于灾难恢复 Redis 加载 RDB 恢复数据远远快于 AOF 的方式 缺点: RDB 方式数据没办法做到 实时持久化/秒级持久化. 因为 bgsave 每次运行都要执行 fork 操作创建子进程, 属于重量级操作, 频繁执行成本太高 RDB 文件使用特定的二进制格式保存, Redis 版本演进过程中有多个格式 RDB 版本, 存在老版本 Redis 服务无法兼容新版本 RDB 格式问题 AOF(append only file) 以独立日志的方式记录每次写命令, 重启时在重新执行 AOF 文件中的命令达到恢复数据的目的. AOF 的主要作用是解决了数据持久化的实时性, 目前已是 Redis 持久化的主流方式 如何开启AOF 开启 AOF 功能需要设置配置: appendonly yes, 默认不开启. AOF 文件名通过 appendfilename 配置设置, 默认文件名是 appendonly.aof. 保存路径同 RDB 持久化方式一致, 通过 dir 配置指定 优点: 使用 AOF 持久化会让 Redis 变的非常耐久: 你可以设置不同的 fsync 策略, 比如无 fsync, 每秒钟一次 fsync, 或者每次执行写入命令时 fsync. AOF 的默认策略为每秒钟 fsync 一次, 在这种配置下, Redis 仍然能够保持良好的性能, 并且就算发生故障停机, 也最多只会丢失一秒钟数据 缺点: 对于相同的数据集来说, AOF 文件的体积通常要大于 RDB 文件的体积. 根据所使用的 fsync 策略, AOF 的速度可能会慢与 RDB. 在一般情况下, 每秒 fsync 的性能依然非常高, 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快, 即使在高负荷之下也是如此. 不过在处理巨大的写入载入时, RDB 可以提供更有保证的最大延迟时间 数据恢复速度相对于 RDB 比较慢 AOF和RDB的区别 RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘, 实际操作过程是 fork 一个子进程, 先将数据集写入临时文件, 写入成功后, 在替换之前的文件, 用二进制压缩存储 AOF持久化以日志的形式记录服务器所处理的每一个写, 删除操作, 查询操作不会记录, 以文本的方式记录, 可以打开文件看到详细的操作记录 性能和解决方案 通过上面的分析, 我们都知道 RDB 的快照, AOF 的重写都需要 fork, 这是一个重量级操作, 会对 Redis 造成阻塞. 因此为了不影响 Redis 主进程, 我们需要尽可能降低阻塞. 如何减少 fork 操作的阻塞 (1) 优先使用物理机或者高效支持 fork 操作的虚拟化技术 (2) 控制 Redis 实例最大可用内存, fork 耗时跟内存量成正比, 线上建议每个 Redis 实例内存控制在 10G 以内 (3) 合理配置 LINUX 内存分配策略, 避免物理内存不足导致 fork 失败 (4) 降低 fork 操作的频率, 如适度放宽 AOF 自动触发时机, 避免不必要的全量复制等 参考博文[1] 吐血整理60个Redis面试题,全网最全了[2] 天天用Redis，持久化方案你知道哪些？","categories":[{"name":"REDIS","slug":"REDIS","permalink":"https://zhuxv.github.io/categories/REDIS/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"REDIS","slug":"REDIS","permalink":"https://zhuxv.github.io/tags/REDIS/"}],"author":"Zhu Xv"},{"title":"PHP练习题-MySQL篇","slug":"PHP练习题-MySQL篇","date":"2020-09-25T06:17:43.000Z","updated":"2020-09-27T08:09:45.863Z","comments":true,"path":"2020/09/25/PHP练习题-MySQL篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/25/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-MySQL%E7%AF%87/","excerpt":"MySQL篇","text":"MySQL篇 1.MySQL的复制原理及其流程:1.主[binlog线程] 记录下所有改变了数据库数据的语句, 放进 master 上的 binlog 中 2.从[io线程] 在使用 start slave 之后, 负责从 master 上拉取 binlog 内容, 放进自己的 relay log 中 3.从[sql执行线程] 执行 relay log 中的语句 2.MySQL中MyISAM与InnoDB的区别:1 五点不同 (1) InnoDB支持事务, MyISAN不支持事务 (2) InnoDB支持行级锁, MyISAN支持表级锁 (3) InnoDB支持多版本并发控制(MVCC), MyISAN不支持MVCC (4) InnoDB支持外键, MyISAN不支持外键 (5) InnoDB不支持全文索引, 而MyISAN不支持索引 2 InnoDB引擎的4大特征 (1) [插入缓冲(insert buffer)](https://blog.csdn.net/dbanote/article/details/9077113) (2) [二次写(double write)](https://blog.csdn.net/dbanote/article/details/9078091) (3) [自适应哈希索引(ahi)](https://blog.csdn.net/dbanote/article/details/9078129) (4) [预读(read ahead)](https://blog.csdn.net/qq9808/article/details/105846413) 3 MyISAN和InnoDB统计哪个更快 MyISAN更快, 因为MyISAN内部维护了一个计数器 4 MyISAN和InnoDB的选择 (1) 需要支持事务,行级锁,外键选择InnoDB (2) 如果表中没有大量的新增删除修改,对原子性要求低,那么MyISAN是最好的选择(更建议使用nosql) (3) 系统崩溃后MyISAM恢复起来更困难 (4) 高并发建议使用InnoDB 3.MySQL中varchar与char的区别以及varchar(50)中的50代表的含义:1.char是一种固定长度的类型, varchar则是一种可变长度类型 2.varchar(50)中50的含义最多存放50个字符, varchar(50)和varchar(200)存储相同字符串所占空间一样,但是后者在排序时会消耗更多内存, 因为 order by col 采用 fixed_length 长度计算 col 长度(memory引擎也一样) 4.InnoDB事务与日志的实现方式1.有多少种日志 (1) 错误日志: 记录出错信息, 也记录一些警告和正确信息 (2) 查询日志: 记录所有对数据库请求的信息, 不论这些请求是否得到了正确的执行 (3) 慢查询日志: 设置一个阈值, 将运行时间超过该值的查询语句记录到日志中 (4) 二进制日志: 记录对数据库执行更改的所有操作 (5) 中继日志 (6) 事务日志 2.事务的4种隔离级别 (1) 读未提交(RU) (2) 读已提交(RC) (3) 可重复度(RR) (4) 串行 3.事务是如何通过日志来实现的 事务日志是通过 redio 和 innodb 的存储引擎日志缓冲 (Innodb log buffer) 来实现的, 当开始一个事务的时候, 会记录该事物的 isn(log sequence number)号; 当事务执行时, 会往 InnoDB 存储引擎日志的日志缓存里面插入事务; 当事务提交时, 必须将存储引擎的日志缓冲写入磁盘 (通过 innodb_flush_log_at_trx_commit 来控制), 也就是写数据前, 需要先写日志. 这种方式称为 &quot;预写日志方式&quot; 5.MySQL binlog的几种日志录入格式以及区别1.Statement: 每一条会修改数据的 sql 都会记录在 binlog 中 优点: 不需要记录每一行的变化, 减少了 binlog 的日志量, 节约了 IO, 提高了性能 缺点: 由于记录的只是执行语句, 为了这些语句能在 slave 上正确运行, 因此还必须记录每条语句在执行的时候的一些相关信息, 以保证所有语句能在 slave 得到和在 master 端执行时候的相同结果. 另外 mysql 的复制, 像一些特定函数功能, slave 可与 master 上要保持一致会有很多先关问题,比如使用一些函数将会出现一些问题或无法复制的现象 2. Row: 不记录 sql 语句上下文相关信息, 仅保存哪条记录被修改 优点: binlog 中不记录执行 sql 相关上下文信息, 仅需要记录哪一条记录被修改成什么了.所以 rowlevel 的日志内容会非常清楚的记录下每一行的数据修改的细节. 而且不会出现某些特定情况下的存储过程或 function 以及 trigger 的调用和触发无法被正确复制的问题 缺点: 所有的执行语句当记录到日志中的时候, 都将以每行记录的修改来记录, 这样会产生大量的日志内容 3. MixedLevel: 是以上两种级别的混合使用, 一般的语句修改使用 statement 格式保存 binlog, 如一些函数, statement 无法完成主从复制的操作, 则采用 row 格式保存 binlog, MySQL 会根据执行的每一条具体的 sql 语句来区分对待记录的日志形式, 也就是在 Statement 和 Row 之间选择一种, 新版本的 MySQL 中对 row level 模式也被做了优化, 并不是所有的修改都会以 row level 来记录, 像遇到表结构变更的时候就会以 statement 模式来记录. 至于 update 或者 delete 等修改数据的语句, 还是会记录所有行的变更 6.MySQL数据库CPU飙升到500%如何处理1. 列出所有进程 show processlist 观察所有进程, 多秒没有状态变化的 kill 掉 2. 查看超时日志或者错误日志, 一般会是查询以及大批量的插入会导致 CPU 与 I/O 上涨 7.sql优化1. 避免全文扫描, 首先考虑在 where 及 order by 上建立索引 2. 避免在 where 子句中对字段进行 null 判断, 避免使用 != &lt;&gt; 操作符, 避免使用 or 查询 3. in 和 not in 也要慎重使用, 很多时候使用 exists 代替 in 是一个很好的选择 4. 使用 like 时禁止左边模糊查询 5. 在 where 子句中避免对字段进行表达式操作 示例: where num/2=100 应改为 where num=100*2 6. 不要在 where 子句中的等于号 &quot;=&quot; 左边进行函数,算术表达式及其他表达式运算 7. 在使用索引字段作为条件时, 如果该索引是复合索引, 那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引, 否则该索引将不会被使用, 并且应尽可能的让字段顺序与索引顺序保持一致 8. 如果有大量重复数据时,这个字段应该避免建立索引 9. 索引可以提高查询效率, 但同样也可以降低插入和编辑效率, 所以要适量建立索引,一张表最好不超过6个索引 10. 尽量使用数字型字段, 字符型字段会降低查询和连接的性能, 并增加存储开销 11. 尽量使用 varchar 代替 char, 可以节约存储空间, 在一个相对较小的字段内搜索效率显然会更高一些 12. 查询时应该用具体字段代替 * 查询 13. 避免频繁创建临时表和删除临时表, 以减少系统表资源的消耗 14. 临时表并不是不可以使用, 当需要重复引用大型表或常用表中的某个数据集时 15. 在新建临时表时, 如果一次性插入数据量过大, 那么可以使用 select into 代替 create table, 避免造成大量log. 如果数据量不大, 为了缓和表的资源, 应先使用 create table, 然后 insert 16. 如果使用到了临时表, 在存储过程的最后务必将所有的临时表显式删除, 先 truncate table, 然后 drop table, 这样可以避免系统表较长时间锁定 17. 尽量避免使用游标查询, 因为游标查询效率太差, 如果有游标操作的数据超过 1万 行, 那么应该考虑改写 18. 使用游标或者临时表方法之前, 应先寻找基于集的解决方案来解决问题, 基于集的方法通常更有效 19. 尽量避免大事务操作, 提高系统并发能力 20. 尽量避免向客户返回大量数据, 若数据量过大, 应该考虑相应需求是否合理 8.InnoDB的读写参数优化1. innodb_buffer_poor_size: 用于缓冲数据和索引, 对于mysql的性能升级是线性的, 通常对于独立的 MySQL 服务器, innodb_buffer_poor_size最大可设置为内存大小的 70%-80% 计算方法: val = Innodb_buffer_pool_pages_data / Innodb_buffer_pool_pages_total * 100% val &gt; 95% 则考虑增大 innodb_buffer_pool_size， 建议使用物理内存的75% val &lt; 95% 则考虑减小 innodb_buffer_pool_size， 建议设置为：Innodb_buffer_pool_pages_data * Innodb_page_size * 1.05 / (1024*1024*1024) 2. 开启慢查询日志 slow.log, 增加参数: log_queries_not_using_indexes, 所有没有走索引的 sql 语句都会记录到 slow.log 中 3. 提高 query_cache 的命中率 命中率计算方法: Qcache_hits/(Qcache_hits + Qcache_inserts) * 100% 提高 qcache 命中率的方法: 数据动静分离 操作频繁的表和操作不频繁的表分开存放, 数据频繁更改会导致 query_cache 失效 单条 sql 语句的 query_cache 大小是有限制的, 当一条 sql 语句返回的数据大小超过 query_cache_limit 的值时不会缓存,可以适量增加 query_cache_limit 的值. query_cache_size 表示所有 query_cache 的总大小. 当整个数据库的 query_cache 大小超过该值, sql 语句也无法缓存 4. 高并发的情况下建议关闭 query_cache, 不然会有很多的 qcache 锁等待 9.你们的数据库是否支持emoji表情, 如果不支持, 应该怎么做如果是 UTF-8 字符集的话升级至 utf8-mb4 即可 10.表中有大字段x(例如: text类型),且字段x不会经常更新,已读为主,你会选择拆成子表还是放在一起,理由?拆开带来的问题: 连接消耗+存储拆分空间 不拆带来的问题: 查询性能 如果能容忍拆分带来的空间问题: 拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区)顺序IO,减少连接消耗, 最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗 如果能容忍不拆分带来的查询性能损失的话: 上面的方案在某个极致条件下肯定会出现问题, 那么不拆是最好的选择 11.MySQL中InnoDB引擎的行锁是通过加在什么上实现的,为什么InnoDB 是基于索引来完成行锁 例: select * from `table` where id=1 for update; for update 可以根据条件来完成行锁锁定, 并且 id 是有索引键的列, 如果 id 不是索引键, 那么 InnoDB 将完成表锁, 只有在 InnoDB 引擎和事务中才能生效 12.开放性问题:一个6亿的表a, 一个3亿的表b, 通过外键 tid 关联, 你如何最快的查询出满足条件的第 50000-50200 的 200 条数据的记录 1. 如果a表 tid 是自增长的, 并且是连续的, b表的 ID 为索引 select * from a,b where a.tid = b.id and a.tid &gt; 50000 limit 200; 2. 如果a表的 tid 不是连续增长的, 那么就需要使用覆盖索引. tid 要么是主键, 要么是辅助索引, b表 ID 也要有索引 select * from b, (select tid from a limit 50000,200) a where b.id = a.tid 参考博文[1] 【MySQL】20个经典面试题[2] sql优化的几种方式[3] 关于mysql innodb引擎性能优化的一点心得","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/tags/MySQL/"},{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"author":"Zhu Xv"},{"title":"apache与nginx的区别","slug":"apache与nginx的区别","date":"2020-09-25T02:06:57.000Z","updated":"2020-09-29T09:06:18.906Z","comments":true,"path":"2020/09/25/apache与nginx的区别/","link":"","permalink":"https://zhuxv.github.io/2020/09/25/apache%E4%B8%8Enginx%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"apache与nginx的区别记录一下apache与nginx的区别, 以便在工作中可以正确选择","text":"apache与nginx的区别记录一下apache与nginx的区别, 以便在工作中可以正确选择 Nginx:1.轻量级, 采用C编写, 同样的web服务, 会占用更少的内存及资源 2.抗并发, 处理请求是异步非阻塞的, 负载能力比 apache 高很多, 而 apache 则是阻塞型的. 在高并发下 nginx 能保持低资源低消耗高性能, 而 apache 在 PHP 处理慢或者前端压力很大的情况下, 很容易出现进程数飙升, 从而拒绝服务现象 3.nginx 处理静态文件好, 静态处理性能是 apache 的三倍以上 4.nginx 的设计高度模块化, 编写模块相对简单 5.nginx 配置简洁, 正则配置让很多事情变得简单, 而且改完配置能使用 nginx -t 测试配置有没有问题, apache 配置复杂, 重启之后发现配置错误,会很崩溃 6.nginx 作为负载均衡服务器, 支持 7 层负载均衡 7.nginx 本身就是一个反向代理服务器, 而且可以作为非常优秀的邮件代理服务器 8.启动特别容易, 并且可以做到 24 小时不断运行, 即使运行数月也不需要重新启动, 还能够不间断服务的情况下进行版本升级 9.社区活跃, 各种高性能模块出品迅速 Apache:1.apache 的 rewrite 比 nginx 强大, 在 rewrite 频繁的情况下, 用 apache 2.apache 发展到现在, 模块超多, 基本想到的都可以找到 3.apache 更为成熟, 少 BUG, nginx BUG 相对比较多 4.apache 非常稳定 5.apache 对 PHP 支持比较简单, nginx 需配合其他后端用 6.apache 在处理动态请求的时候有优势, nginx 在这方面是鸡肋, 一般动态请求要 apache 去做, nginx 适合反向和静态 7.apache 仍然是目前的主流, 拥有丰富的特性, 成熟的技术和开发社区 总结两者最核心的区别在于 apache 是同步多进程模型, 一个连接对应一个进程, 而 nginx 是异步的, 多连接可以对应一个进程一般来说, 需要性能的 web 服务, 用 nginx, 如果不需要性能只要求稳定的服务, 更考虑的是 apache, 后者各种功能模块实现的比前者好, 可配置项多更为通用的方案是, 前端 nginx 抗并发, 后端 apache 集群, 配合起来会更好 参考博文[1] Apache和Nginx的区别","categories":[{"name":"服务","slug":"服务","permalink":"https://zhuxv.github.io/categories/%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"服务","slug":"服务","permalink":"https://zhuxv.github.io/tags/%E6%9C%8D%E5%8A%A1/"}],"author":"Zhu Xv"},{"title":"PHP练习题-基础篇","slug":"PHP练习题-基础篇","date":"2020-09-25T02:00:23.000Z","updated":"2020-09-29T09:40:03.703Z","comments":true,"path":"2020/09/25/PHP练习题-基础篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/25/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"基础篇","text":"基础篇 1.PHP语言的一大优势是跨平台,什么是跨平台PHP运行环境可以在不同的操作系统(例如: windows, linux等)上配置, 不受操作系统的限制, 所以叫跨平台 敬请期待…","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"}],"author":"Zhu Xv"},{"title":"PHP练习题-字符串篇","slug":"PHP练习题-字符串篇","date":"2020-09-24T08:47:53.000Z","updated":"2020-09-25T09:13:46.521Z","comments":true,"path":"2020/09/24/PHP练习题-字符串篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/24/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/","excerpt":"字符串篇","text":"字符串篇 1.定义一个生成随机字符串的函数1234567891011121314/** * 生成随机字符串 * @param int $length 长度 * @return string */function generate_random_string(int $length=10)&#123; $chars = &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;; $randomString = &#x27;&#x27;; for ( $i=0; $i&lt;$length; $i++ ) &#123; $randomString .= $chars[rand(0, strlen($chars)-1)]; &#125; return $randomString;&#125; 2.不使用函数,写一个字符串反转的函数1234567891011121314/** * 字符串反转函数 * @param string $str * @return string */function str_inver( string $str )&#123; $newStr = &#x27;&#x27;; $m = strlen($str) - 1; for( $i=$m; $i&gt;=0; $i-- ) &#123; $newStr .= $str[$m]; &#125; return $newStr;&#125; 3.写一个函数,将字符串每几位用指定符号隔开1234567891011121314151617181920/** * 将字符串隔几位用指定符号隔开 * @param string $str * @param string $symbol * @param int $num 每隔几位隔开 * @return string */function separate( string $str, string $symbol=&#x27;,&#x27;, int $num=3)&#123; $newStr = &#x27;&#x27;; $length = strlen($str); // 获取字符串长度 $k = $length%$num; for( $i=0; $i&lt;$length; $i++ ) &#123; if ( $i%$num == $k &amp;&amp; $i != 0 ) &#123; $newStr .= $symbol; &#125; $newStr .= $str[$i]; &#125; return $newStr;&#125; 4.获取文件扩展名123456789101112/** * 获取文件扩展名 * @param string $url 文件路径 * @return string */function ext_name(string $url)&#123; if ( strstr($url, &#x27;?&#x27;) ) &#123; $url = explode(&#x27;?&#x27;, $url)[0]; &#125; return end(explode(&#x27;.&#x27;, $url));&#125; 5.写一个函数,计算出两个文件的相对路径123456789101112131415161718192021222324/** * 计算出两个文件的相对路径 * @param string $path1 * @param string $path2 * @return string */function relative_path( string $path1, string $path2 )&#123; // 获取两文件的目录 $path1 = trim(dirname($path1), &#x27;/&#x27;); $path2 = trim(dirname($path2), &#x27;/&#x27;); $path1Arr = explode(&#x27;/&#x27;, $path1); $path2Arr = explode(&#x27;/&#x27;, $path2); $num = max(count($path1Arr), count($path2Arr)); for( $i=0; $i&lt;$num; $i++ ) &#123; if ( $path1Arr[$i] !== $path2Arr[$i] ) &#123; break; &#125; unset($path1Arr[$i], $path2Arr[$i]); &#125; return str_repeat(&#x27;../&#x27;, count($path2Arr)).implode(&#x27;/&#x27;, $path1Arr);&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"},{"name":"字符串","slug":"字符串","permalink":"https://zhuxv.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Zhu Xv"},{"title":"PHP练习题-数组篇","slug":"PHP联系题-数组篇","date":"2020-09-24T02:55:38.000Z","updated":"2020-09-25T09:16:02.638Z","comments":true,"path":"2020/09/24/PHP联系题-数组篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/24/PHP%E8%81%94%E7%B3%BB%E9%A2%98-%E6%95%B0%E7%BB%84%E7%AF%87/","excerpt":"数组篇通过工作中的几次教训, 终于领悟到题还是要刷滴, 整理出一些常见题型","text":"数组篇通过工作中的几次教训, 终于领悟到题还是要刷滴, 整理出一些常见题型 1. 请使用PHP实现冒泡排序，将数组$a = array()按照从小到大的方式进行排序1234567891011121314151617181920/** * 冒泡排序 * @param array $arr 需要排序的数组 * @return array|false */function bubble_sorting( array $arr )&#123; $len = count($arr); // 最外层循环控制需要冒泡的轮数 for ( $i=1; $i &lt; $len; $i++ ) &#123; for ( $j=0; $j &lt; $len-$i; $j++ ) &#123; if ( $arr[$j] &gt; $arr[$j+1] ) &#123; $tmp = $arr[$j+1]; $arr[$j+1] = $arr[$j]; $arr[$j] = $tmp; &#125; &#125; &#125; return $arr;&#125; 2.创建一个长度为10的数组, 数组中的元素为递增的奇数, 首项为112345678910111213/** * 创建一个元素递增为奇数的数组 * @param int $first 第一个元素的值 * @param int $length 数组长度 */function element_odd_number_arr(int $first=1, int $length=10)&#123; $arr = []; for ( $i=0; $i &lt; $length; $i++ ) &#123; $arr[] = ($i+$first) * 2 - 1; &#125; return $arr;&#125; 3.求出数组中最大下标1234567891011121314151617181920/** * 得出数组中最大值的下标 * @param array $arr * @return mixed */function max_key(array $arr)&#123; $maxKey = false; foreach ( $arr as $key =&gt; $item ) &#123; if ( !isset($maxVal) ) &#123; $maxVal = $item; $maxKey = $key; continue; &#125; if ( $maxVal &lt; $item ) &#123; $maxKey = $key; &#125; &#125; return $maxKey;&#125; 4.创建一个指定长度的数组, 数组中的元素满足斐波拉契数列的规律斐波拉契数列又称黄金分割数, 如下的定义方法: F0=0, F1=1, Fn=F(n-1)+F(n-2)（n&gt;=2，n∈N*） 1234567891011121314151617/** * 创建一个元素满足斐波拉契数列规律的数组 * @param int $length 数组长度 * @return array */function golden_section_arr(int $length=10)&#123; $result = []; for ( $i = 0; $i &lt; $length; $i++ ) &#123; if ( $i &lt; 2 ) &#123; $result[$i] = $i; continue; &#125; $result[$i] = $result[$i-1] + $result[$i-2]; &#125; return $result;&#125; 5.计算数组中最大数和最小数的差12345678910/** * 计算数组中的最大数和最小数的差值 * @param array $arr * @return int */function diff_val(array $arr)&#123; sort($arr); return end($arr)-reset($arr);&#125; 6.截取数组元素后几位拼接到数组前,顺序不变1234567891011121314151617/** * 截取数组元素后几位拼接到数组前 * @param array $arr * @param int $length 要截取的位数 * @return array|false */function cut_splice_arr(array $arr, int $length=1)&#123; $count = count($arr); if ( $count &lt; $length ) &#123; return false; &#125; $front = array_slice($arr, 0, $count-$length, true); $after = array_slice($arr, $count-$length, $length, true); return array_merge($after, $front);&#125; 7.不使用函数,将两个数组组成一个数组12345678910111213/** * 将两个数组组成一个数组 * @param array $arr1 * @param array $arr2 * @return array */function recombinate_array(array $arr1, array $arr2)&#123; foreach ( $arr1 as $_item ) &#123; $arr2[] = $_item; &#125; return $arr2;&#125; 8.数组逆序(不能使用rsort函数, 不能生成新的数组)123456789101112131415161718192021222324252627/** * 数组逆序 * @param array $arr * @return array */function reverse_order_arr(array $arr)&#123; $i = &quot;&quot;; // 要替换位置的数的下标 $j = &quot;&quot;; // 临时变量 $k = &quot;&quot;; // 被替换位置的数的下标 $len = count($arr); $half_len = floor($len/2); // 向下取整,取整的值是循环的次数 for( $i=0; $i&lt;$half_len; $i++ ) &#123; $j = $arr[$i]; // 判断数组个数奇偶 if ( $len % 2 !== 0 ) &#123; $k = $half_len*2-$i; &#125; else &#123; $k = $half_len*2-$i-1; &#125; $arr[$i] = $arr[$k]; $arr[$k] = $j; &#125; return $arr;&#125; 9.快速排序1234567891011121314151617181920212223/** * 数组快速排序 * @param array $arr * @return array */function quick_sort(array $arr)&#123; $count = count($arr); if ( $count &lt;= 1 ) return $arr; $key = $arr[0]; $left_arr = []; $right_arr = []; for ( $i=1; $i&lt;$count; $i++ ) &#123; if ( $arr[$i] &lt;= $key ) &#123; $left_arr[] = $arr[$i]; &#125; else &#123; $right_arr[] = $arr[$i]; &#125; &#125; $left_arr = quick_sort($left_arr); $right_arr = quick_sort($right_arr); return array_merge($left_arr, [$key], $right_arr);&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"},{"name":"数组","slug":"数组","permalink":"https://zhuxv.github.io/tags/%E6%95%B0%E7%BB%84/"}],"author":"Zhu Xv"}],"categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://zhuxv.github.io/categories/WEB%E5%AE%89%E5%85%A8/"},{"name":"架构","slug":"架构","permalink":"https://zhuxv.github.io/categories/%E6%9E%B6%E6%9E%84/"},{"name":"MVC","slug":"MVC","permalink":"https://zhuxv.github.io/categories/MVC/"},{"name":"REDIS","slug":"REDIS","permalink":"https://zhuxv.github.io/categories/REDIS/"},{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/categories/MySQL/"},{"name":"服务","slug":"服务","permalink":"https://zhuxv.github.io/categories/%E6%9C%8D%E5%8A%A1/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://zhuxv.github.io/tags/WEB/"},{"name":"安全","slug":"安全","permalink":"https://zhuxv.github.io/tags/%E5%AE%89%E5%85%A8/"},{"name":"DDOS","slug":"DDOS","permalink":"https://zhuxv.github.io/tags/DDOS/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://zhuxv.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"XSS","slug":"XSS","permalink":"https://zhuxv.github.io/tags/XSS/"},{"name":"架构","slug":"架构","permalink":"https://zhuxv.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"RESTful","slug":"RESTful","permalink":"https://zhuxv.github.io/tags/RESTful/"},{"name":"MVC","slug":"MVC","permalink":"https://zhuxv.github.io/tags/MVC/"},{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"REDIS","slug":"REDIS","permalink":"https://zhuxv.github.io/tags/REDIS/"},{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/tags/MySQL/"},{"name":"服务","slug":"服务","permalink":"https://zhuxv.github.io/tags/%E6%9C%8D%E5%8A%A1/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"},{"name":"字符串","slug":"字符串","permalink":"https://zhuxv.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数组","slug":"数组","permalink":"https://zhuxv.github.io/tags/%E6%95%B0%E7%BB%84/"}]}