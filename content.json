{"meta":{"title":"小朱的技术博客","subtitle":"","description":"","author":"Zhu Xv","url":"https://zhuxv.github.io","root":"/"},"pages":[{"title":"","date":"2020-11-26T06:16:09.737Z","updated":"2020-11-26T06:16:09.624Z","comments":true,"path":"about/index.html","permalink":"https://zhuxv.github.io/about/index.html","excerpt":"","text":"关于我我叫朱旭,来自安徽淮北,今年二十四岁,毕业于淮北职业技术学院计算机系目前工作已经四年了.目前工作在上海晟柯软件科技有限公司担任PHP开发,主要负责接口开发,接口对接,后台供应商管理系统(SMS)与资源管理系统(ERM)开发与维护,web,H5和小程序开发与维护,服务器维护,数据库设计,文档编写,云平台对接我的职业技能有:PHP,服务器,MYSQL,NOSQL,HTML,CSS,JQUERY我使用过的框架: TP3.2 TP5.1 laravel7 kohana3.2我熟悉的编程环境: LAMP LNMP WAMP我喜欢开发新的功能,封装功能模块,对于新的知识乐于钻研学习,我喜欢优雅的代码平时喜欢看php相关书籍,打打游戏,旅行我的职业生涯目标是往架构师方向发展 关于工作城市：上海 关于学习正在往终身学习者前进…近期学习方向：Linux(服务器, 运行环境) 语录 深林几处啼鹃, 梦如烟 关于爱好热爱游戏，尤其喜爱阅读、电影、旅行。 联系我 Home: zhuxv.com Blog: zhuxv.github.io Email: &#49;&#x30;&#55;&#x31;&#x37;&#x38;&#x36;&#x32;&#x30;&#x34;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#x6d; GitHub: ZhuXv WeiBo: Twitter:"}],"posts":[{"title":"PHP7新特性","slug":"PHP7新特性","date":"2020-11-26T06:26:25.000Z","updated":"2020-11-26T08:53:28.617Z","comments":true,"path":"2020/11/26/PHP7新特性/","link":"","permalink":"https://zhuxv.github.io/2020/11/26/PHP7%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"PHP7+版本极大地改进了性能,在一些WordPress基准测试中,性能可以达到PHP5.6的三倍","text":"PHP7+版本极大地改进了性能,在一些WordPress基准测试中,性能可以达到PHP5.6的三倍 标量类型与返回值类型声明标量类型声明默认情况下,所有的PHP文件都处于弱类型校验模式PHP7增加了标量类型声明的特性,标量类型声明有两种模式 强制模式(默认) 严格模式标量类型声明语法格式1declare(strict_types=1) 代码中通过指定strict_types的值(1或者0),1表示严格类型校验模式,作用于函数调用和返回语句;0表示弱类型校验模式可以使用的参数类型有: int float bool string interfaces array callable返回类型声明PHP7增加了对返回类型声明的支持,返回类型声明指明了函数返回值的类型可以声明的返回类型: int float bool string interfaces array callablevoid函数一个新的返回值类型void被引入.返回值声明为void类型的方法要么干脆省去return语句,要么使用一个空的return语句.对于void函数来说,NULL不是一个合法的返回值返回类型还有void,定义返回类型为void的函数不能有返回值,即使返回null也不行PHP NULL 合并运算符PHP7新增加的NULL合并运算符(??)是用于执行isset()检测的三元运算符的快捷方式NULL合并运算符会判断变量是否存在且值不为NULL,如果是,他就会返回自身的值,否则返回它的第二个操作数太空船运算符(组合比较符)PHP7新增加的太空船运算符(组合比较符)用于比较两个表达式$a和$b,如果$a小于,等于或大于$b时,它分别返回-1,0,1123print(1&lt;=&gt;1); // 0 print(1&lt;=&gt;2); // -1 print(2&lt;=&gt;1); // 1 常量数组在PHP5.6中仅能通过const定义常量数组, PHP7可以通过 define()来定义123456define(&#x27;SITES&#x27;,[ &#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;]);print(SITES[1]); 匿名类PHP7支持通过new class来实例化一个匿名类,这可以用来代替一些”用后即焚”的完整类的定义12345678910111213141516171819202122interface Logger&#123; public function log(string $msg);&#125;class Application &#123; private $logger; public function getLogger():Logger&#123; return $this-&gt;logger; &#125; public function setLogger(Logger $logger) &#123; $this-&gt;logger = $logger; &#125;&#125;$app = new Application;// 使用 new class 创建匿名类$app-&gt;setLogger(new class implements Logger&#123; public function log(string $msg) &#123; print($msg); &#125;&#125;);$app-&gt;getLogger()-&gt;log(&#x27;Hello New Class&#x27;); Closure::call()PHP7的Closure::call()有着更好的性能,将一个闭包函数动态绑定到一个新的对象实例并调用执行该函数1234567class A&#123; private $x = 1;&#125;$getX = function()&#123; return $this-&gt;x;&#125;echo $getX-&gt;call(new A); // 1 PHP过滤unserialize()PHP7增加了可以为unserialize()提供过滤的特性,可以防止非法数据进行代码注入,提供了更安全的反序列化数据12345678910111213141516171819202122232425class MyClass1&#123; public $obj1prop;&#125;class MyClass2&#123; public $obj2prop;&#125;$obj1 = new MyClass1();$obj1-&gt;obj1prop = 1;$obj2 = new MyClass2();$obj2-&gt;obj2prop = 2;$serializedObj1 = serialize($obj1);$serializedObj2 = serialize($obj2);// 默认行为是接收所有类// 第二个参数可以忽略// 如果 allowed_classes 设置为 false, unserialize 会将所有对象转换为 __PHP_Incomplete_Class 对象$data = unserialize($serializedObj1, [&quot;allowed_classes&quot;=&gt;true]);// 转换所有对象到 __PHP_Incomplete_Class 对象,只允许 MyClass1 和 MyClass2 转换到 __PHP_Incomplete_Class$data2 = unserialize($serializedObj2, [&quot;allowed_classes&quot;=&gt;[&quot;MyClass1&quot;,&quot;MyClass2&quot;]]);print($data-&gt;obj1prop); // 1print($data-&gt;obj2prop); // 2 CSPRNGCSPRNG( Cryptographically Secure Pseudo-Random Number Generator, 伪随机数产生器 ).PHP7通过引入几个CSPRNG函数提供一种简单的机制来生成密码学上强壮的随机数 random_bytes() - 加密生存被保护的伪随机字符串 random_int() - 加密生存被保护的伪随机整数random_bytes()语法格式1string random_bytes(int $length) 参数 length - 随机字符串返回的字节数返回值 返回一个字符串,接受一个int型入参代表返回结果的字节数random_int()语法格式1int random_bytes(int $min, int $max) 参数 min - 返回的最小值,必须是大于或等于 PHP_INT_MIN max - 返回的最大值,必须是小于或等于 PHP_INT_MAX返回值 返回一个指定范围内的int型数字异常PHP7异常用于向下兼容及增强旧的assert()函数,他能在生产环境中实现零成本断言,并且提供抛出自定义异常及错误能力.老版本的API出于兼容目的将继续被维护,assert()现在是一个语言结构,它允许第一个参数是一个表达式,而不仅仅是一个待计算的string或一个待测试的booleanassert配置 配置项 默认值 可选值 zend.assertions 1 1 - 生成和执行代码(开发模式)0 - 生成代码,但在执行时跳过它-1 - 不生成代码(生产环境) assert.exception 0 1 - 断言失败时抛出,可以抛出异常对象,如果没有提供异常,则抛出AssertionError对象实例0 - 使用或生成 Throwable,仅仅是基于对象生成的警告而不是抛出对象(与PHP5兼容) 参数: assertion 断言.在PHP5中,是一个用于执行的字符串或者用于测试的布尔值.在PHP7中,可以是一个返回任何值的表达式,它将被执行结果用于指明断言是否成功. description 如果assertion失败了,选项description将会包括在失败信息里 exception 在PHP7中,第二个参数可以是一个Throwable对象,而不是一个字符串,如果断言失败且弃用了assert.exception该对象将被抛出 use语句PHP7可以使用一个use从同一个namespace中导入类,函数和常量 123456789use some\\namespace\\&#123; ClassA,ClassB,ClassC as C&#125;;use function some\\namespace\\&#123; fn_a,fn_b,fn_c&#125;;use const some\\namespace\\&#123; ConstA,ConstB,ConstC&#125;; 错误处理PHP7改变了大多数错误报告方式.不同于PHP5的传统错误报告机制,现在大多数错误被作为Error异常抛出.这种Error异常可以像普通异常一样被try/catch块所捕获.如果没有匹配的try/catch块,则调用异常处理函数(由set_exception_handler()注册)进行处理.如果尚未注册异常处理函数,则按照传统方式处理:被报告为一个致命错误(Fatal Error)Error类并不是从Exception类扩展出来的,所以用catch(Exception $e){…}这样的代码是捕获不到Error的.你可以用catch(Error $e){…}这样的代码,或者通过注册异常处理函数(set_exception_handler())来捕获Error Error异常层次结构 intdiv()函数PHP7新增加了intdiv()函数,接收两个参数,返回值为第一个参数除于第二个参数的值并取整 SESSION选项PHP7 session_start()函数可以接收一个数组作为参数,可以覆盖php.ini中session的配置项这个特性也引入了一个新的php.ini设置(session.lazy_write),默认情况下设置为true,意味着session数据只在发生变化时才写入.除了常规的会话配置指示项,还可以在此数组中包含read_and_close选项.如果将此选项的值设置为TRUE,那么会话文件会在读取完毕之后马上关闭,因此,可以在会话数据没有变动的时候,避免不必要的文件锁 废弃特性PHP4风格的构造函数在PHP4中类中的函数可以与类名同名,这一特性在PHP7中废弃,同时会发出一个E_DEPRECATED错误.当方法名与类同名,且类不在命名空间中,同时PHP5的构造函数__construct不存在时,会产生一个E_DEPRECATED错误 以静态方法调用费静态方法以静态方法调用费静态方法,不在支持 password_hash()随机因子选项函数原salt量不在需要由开发者提供了.函数内部默认带有salt能力,无需开发者提供salt值 capture_session_meta SSL 上下文选项废弃了”capture_session_meta” SSL 上下文选项. 在资源上活动的加密相关的元数据可以通过stream_get_meta_data()的返回值访问 移除的扩展 ereg mssql mysql sybase_ct 参考博文[1] PHP7新特性|菜鸟教程","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"PHP7","slug":"PHP7","permalink":"https://zhuxv.github.io/tags/PHP7/"}],"author":"Zhu Xv"},{"title":"Elasticsearch学习","slug":"Elasticsearch学习","date":"2020-11-25T03:55:41.000Z","updated":"2020-11-26T05:56:38.619Z","comments":true,"path":"2020/11/25/Elasticsearch学习/","link":"","permalink":"https://zhuxv.github.io/2020/11/25/Elasticsearch%E5%AD%A6%E4%B9%A0/","excerpt":"Elasticsearch是一个基于Lucene的搜索服务器.他提供了一个分布式多用户能力的全文搜索引擎,基于RESTful web 接口.Elasticsearch是基于java开发的,并作为Apache许可条款下的开放源码,是一种流行的企业级搜索引擎.Elasticsearch用于云计算中,能够达到实时搜索,稳定,可靠,快速,安装使用方便.","text":"Elasticsearch是一个基于Lucene的搜索服务器.他提供了一个分布式多用户能力的全文搜索引擎,基于RESTful web 接口.Elasticsearch是基于java开发的,并作为Apache许可条款下的开放源码,是一种流行的企业级搜索引擎.Elasticsearch用于云计算中,能够达到实时搜索,稳定,可靠,快速,安装使用方便. 安装安装之前,你需要安装一个较新版本的java,最好的选择是,你可以从www.java.com获得官方提供的最新版本的java之后你可以从elasticsearch的官网elastic.co/downloads/elasticsearch获取最新版本的Elasticsearch windows下运行运行 bin\\elasticsearch.bat 测试运行执行终端操作 1curl &#x27;http://localhost:9200/?pretty&#x27; 显示 1234567891011121314151617&#123; &quot;name&quot;: &quot;USER-A65S1LK1SI&quot;, &quot;cluster_name&quot;: &quot;elasticsearch&quot;, &quot;cluster_uuid&quot;: &quot;YwHOZZG4ThW4Cwex2dtweA&quot;, &quot;version&quot;: &#123; &quot;number&quot;: &quot;7.9.1&quot;, &quot;build_flavor&quot;: &quot;default&quot;, &quot;build_type&quot;: &quot;zip&quot;, &quot;build_hash&quot;: &quot;083627f112ba94dffc1232e8b42b73492789ef91&quot;, &quot;build_date&quot;: &quot;2020-09-01T21:22:21.964974Z&quot;, &quot;build_snapshot&quot;: false, &quot;lucene_version&quot;: &quot;8.6.2&quot;, &quot;minimum_wire_compatibility_version&quot;: &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot;: &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot;: &quot;You Know, for Search&quot;&#125; 则表示安装成功 交互RESTful API with JSON over HTTPPHP Elasticsearch官方客户端可在Elasticsearch Client中下载一个Elasticsearch请求和任何HTTP请求一样由若干相同部件组成: 1curl -X&lt;VERB&gt; &#x27;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&#x27; -d &#x27;&lt;BODY&gt;&#x27; 创建索引文档对于文档目录,我们将做如下操作 每个员工索引一个文档,文档包含该员工的所有信息 每个文档都将是employee类型 该类型位于索引/megacorp内 该索引保存在我们的Elasticsearch集群中12345678PUT /megacorp/employee/1&#123; &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Smith&quot;, &quot;age&quot;: 25, &quot;about&quot;: &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [&quot;sports&quot;,&quot;music&quot;]&#125; megacorp: 索引名称employee: 类型名称1: 特定雇员的ID返回信息:1234567891011121314&#123; &quot;_index&quot;: &quot;megacorp&quot;, &quot;_type&quot;: &quot;employee&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;, &quot;_seq_no&quot;: 0, &quot;_primary_term&quot;: 1&#125; 检索文档目前我们已经在Elasticsearch中存储了一些数据,接下来就能专注于实现应用的业务需求了.第一个需求是可以检索到单个雇员的数据.简单的执行一个HTTPGET请求并指定文档的地址-索引库,类型和ID1GET /megacorp/employee/1 当执行上一步操作的时候,返回结果包含了文档的一些元数据,以及_source属性,内容是John Smith雇员的原始JSON文档:12345678910111213141516171819&#123; &quot;_index&quot;: &quot;megacorp&quot;, &quot;_type&quot;: &quot;employee&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;_seq_no&quot;: 0, &quot;_primary_term&quot;: 1, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Smith&quot;, &quot;age&quot;: 25, &quot;about&quot;: &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ] &#125;&#125; 将HTTP命令由PUT改为GET可以用来检索文档,同样的,可以使用DELETE命令来删除文档,以及使用HEAD指令来检查文档是否存在,如果想更新已存在的文档,只需再次PUT轻量搜索接下来我们使用下列请求来搜索所有雇员:123456789101112131415161718192021222324252627282930313233343536GET /megacorp/employee/_search&#123; &quot;took&quot;: 547, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 1, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 1, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;megacorp&quot;, &quot;_type&quot;: &quot;employee&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: &#123; &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Smith&quot;, &quot;age&quot;: 25, &quot;about&quot;: &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ] &#125; &#125; ] &#125;&#125; 返回结果包含在hits数组中默认返回十条返回结果不仅告知匹配了哪些文档,还包含整个文档本身:显示搜索结果给最终用户所需的全部信息接下来尝试搜索姓氏为 “Smith” 的雇员.为此,我们将使用一个高亮搜索,很容易通过命令行完成.这个方法一般涉及到一个*查询字符串(query-string)*搜索,因为我们通过一个URL参数来传递查询信息给搜索接口123456789101112131415161718192021222324252627282930313233343536GET /megacorp/employee/_search?q=last_name:Smith&#123; &quot;took&quot;: 111, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 1, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 0.2876821, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;megacorp&quot;, &quot;_type&quot;: &quot;employee&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 0.2876821, &quot;_source&quot;: &#123; &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Smith&quot;, &quot;age&quot;: 25, &quot;about&quot;: &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ] &#125; &#125; ] &#125;&#125; 使用查询表达式搜索Query-string搜索通过命令非常方便的进行临时性的即席搜索,但是他有局限性(参见轻量搜索)使用查询表达式搜索,用JSON构建一个请求.我们可以像这样重写之前的查询所有名为Smith的搜索12345678POST /megacorp/employee/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;:&#123; &quot;last_name&quot;: &quot;Smith&quot; &#125; &#125;&#125; 返回结果与之前的查询一样,但是还是可以看到有一些变化.其中之一是,不再使用query-string参数,而是一个请求体代替.这个请求使用JSON构造,并使用了一个match查询(属于查询类型之一,后面将继续介绍)更复杂的搜索现在尝试下更复杂的操作.同样搜索姓氏为Smith的员工,但这次我们只需要年龄大于30的.查询需要稍作调整,使用过滤器filter,它支持高效的执行一个结构化查询1234567891011121314151617POST /megacorp/employee/_search&#123; &quot;query&quot;:&#123; &quot;bool&quot;:&#123; &quot;must&quot;:&#123; &quot;match&quot;:&#123; &quot;last_name&quot;:&quot;Smith&quot; &#125; &#125;, &quot;filter&quot;:&#123; &quot;range&quot;:&#123; &quot;age&quot;:&#123;&quot;gt&quot;:24&#125; &#125; &#125; &#125; &#125;&#125; 这部分与我们之前使用的match查询一样这部分是一个range过滤器,他能找到年龄大于24岁的文档,其中gt表示大于(great than)1234567891011121314151617181920212223242526272829303132333435&#123; &quot;took&quot;: 265, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 1, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 0.2876821, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;megacorp&quot;, &quot;_type&quot;: &quot;employee&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 0.2876821, &quot;_source&quot;: &#123; &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Smith&quot;, &quot;age&quot;: 25, &quot;about&quot;: &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ] &#125; &#125; ] &#125;&#125; 全文搜索截止目前的搜索都相对简单:单个姓名,通过年龄过滤.现在尝试一下稍微高级一点的全文搜索,传统数据库确实很难搞定的任务搜索下所有喜欢攀岩的员工12345678POST /megacorp/employee/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;: &#123; &quot;about&quot;:&quot;rock climbing&quot; &#125; &#125;&#125; 显然我们依旧使用之前的match查询在about属性上搜索”rock climbing”1234567891011121314151617181920212223242526272829303132333435&#123; &quot;took&quot;: 277, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 1, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 0.5753642, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;megacorp&quot;, &quot;_type&quot;: &quot;employee&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 0.5753642, &quot;_source&quot;: &#123; &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Smith&quot;, &quot;age&quot;: 25, &quot;about&quot;: &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ] &#125; &#125; ] &#125;&#125; 相关性得分Elasticsearch默认按照相关性得分排序,即每个文档跟查询的匹配程度.第一个最高得分的结果rock climbing依次排序为about中的 rock 和 climbing短语搜索找出一个属性中的独立单词是没有问题的,但有时候想要精确匹配一系列单词或者短语.比如我们想执行这样一个查询,仅匹配同时包含”rock”和”climbing”, 并且二者以短语”rock climbing”的形式紧挨着的雇员记录为此对match查询稍作调整,使用一个叫做match_phrase的查询:12345678POST /megacorp/employee/_search&#123; &quot;query&quot;:&#123; &quot;match_phrase&quot;:&#123; &quot;about&quot;:&quot;rock climbing&quot; &#125; &#125;&#125; 返回结果1234567891011121314151617181920212223242526272829303132333435&#123; &quot;took&quot;: 141, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 1, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 0.5753642, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;megacorp&quot;, &quot;_type&quot;: &quot;employee&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 0.5753642, &quot;_source&quot;: &#123; &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Smith&quot;, &quot;age&quot;: 25, &quot;about&quot;: &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ] &#125; &#125; ] &#125;&#125; 高亮搜索许多应用都倾向于在每个搜索结果中高亮部分文本片段,以便让用户知道为何该文档符合查询条件.在Elasticsearch中检索出高亮片段也非常容易.再次执行之前的操作,并增加一个新的highlight参数:12345678910111213POST /megacorp/employee/_search&#123; &quot;query&quot;:&#123; &quot;match_phrase&quot;: &#123; &quot;about&quot;:&quot;rock climbing&quot; &#125; &#125;, &quot;highlight&quot;:&#123; &quot;fields&quot;:&#123; &quot;about&quot;:&#123;&#125; &#125; &#125;&#125; 当执行该查询时,返回结果与之前一样,与此同时结果中还多了一个叫做highlight的部分.这个部分包含了about属性匹配的文本片段,并以HTML标签封装:12345678910111213141516171819202122232425262728293031323334353637383940&#123; &quot;took&quot;: 248, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 1, &quot;successful&quot;: 1, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: &#123; &quot;value&quot;: 1, &quot;relation&quot;: &quot;eq&quot; &#125;, &quot;max_score&quot;: 0.5753642, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;megacorp&quot;, &quot;_type&quot;: &quot;employee&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 0.5753642, &quot;_source&quot;: &#123; &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Smith&quot;, &quot;age&quot;: 25, &quot;about&quot;: &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ] &#125;, &quot;highlight&quot;: &#123; &quot;about&quot;: [ &quot;I love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;&quot; ] &#125; &#125; ] &#125;&#125; 分析终于到了最后一个业务需求:支持管理者对员工目录做分析.Elasticsearch有个功能叫做聚合(aggregations),允许我们基于数据生成一些精细的分析结果.聚合与SQL中的GROUP BY类似但更强大举个例子,挖掘出员工中最受欢迎的兴趣爱好:12345678POST /megacorp/employee/_search&#123; &quot;aggs&quot;:&#123; &quot;all_interests&quot;: &#123; &quot;terms&quot;: &#123;&quot;fields&quot;:&quot;interests&quot;&#125; &#125; &#125;&#125; 返回结果12345678910111213141516171819202122&#123; ... &quot;hits&quot;: &#123; ... &#125;, &quot;aggregations&quot;: &#123; &quot;all_interests&quot;: &#123; &quot;buckets&quot;: [ &#123; &quot;key&quot;: &quot;music&quot;, &quot;doc_count&quot;: 2 &#125;, &#123; &quot;key&quot;: &quot;forestry&quot;, &quot;doc_count&quot;: 1 &#125;, &#123; &quot;key&quot;: &quot;sports&quot;, &quot;doc_count&quot;: 1 &#125; ] &#125; &#125;&#125; 如果想知道叫Smith的员工最受欢迎的兴趣爱好,可以直接构造一个组合查询:123456789101112131415POST /megacorp/employee/_search&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;last_name&quot;:&quot;smith&quot; &#125; &#125;, &quot;aggs&quot;:&#123; &quot;all_interests&quot;:&#123; &quot;terms&quot;:&#123; &quot;field&quot;: &quot;interests&quot; &#125; &#125; &#125;&#125; all_interests聚合已经变成只包含匹配查询的文档:1234567891011121314...&quot;all_interests&quot;: &#123; &quot;buckets&quot;: [ &#123; &quot;key&quot;: &quot;music&quot;, &quot;doc_count&quot;: 2 &#125;, &#123; &quot;key&quot;: &quot;sports&quot;, &quot;doc_count&quot;: 1 &#125; ]&#125;... 聚合还支持分级汇总.比如,查询特定兴趣爱好员工的平均年龄12345678910111213POST /megacorp/employee/_search&#123; &quot;aggs&quot;:&#123; &quot;all_interests&quot;:&#123; &quot;terms&quot;:&#123;&quot;field&quot;:&quot;interests&quot;&#125;, &quot;aggs&quot;:&#123; &quot;avg_age&quot;:&#123; &quot;avg&quot;:&#123;&quot;field&quot;:&quot;age&quot;&#125; &#125; &#125; &#125; &#125;&#125; 理解起来还挺简单的1234567891011121314151617181920212223242526...&quot;all_interests&quot;: &#123; &quot;buckets&quot;: [ &#123; &quot;key&quot;: &quot;music&quot;, &quot;doc_count&quot;: 2, &quot;avg_age&quot;: &#123; &quot;value&quot;: 28.5 &#125; &#125;, &#123; &quot;key&quot;: &quot;forestry&quot;, &quot;doc_count&quot;: 1, &quot;avg_age&quot;: &#123; &quot;value&quot;: 35 &#125; &#125;, &#123; &quot;key&quot;: &quot;sports&quot;, &quot;doc_count&quot;: 1, &quot;avg_age&quot;: &#123; &quot;value&quot;: 25 &#125; &#125; ]&#125; 输出基本是第一次聚合的加强版.依然有一个兴趣及数量的列表,只不过每个兴趣都有了一个附加的avg_age属性,代表有这个兴趣爱好的所有员工的平均年龄.集群集群健康Elasticsearch的集群监控信息中包含了许多的统计数据,其中最为重要的一项就是集群健康,他在status字段中展示为green,yellow或red1GET /_cluster/health 在一个不包含任何索引的空集群中,他将会有一个类似于如下所示的返回内容123456789101112&#123; &quot;cluster_name&quot;: &quot;elasticsearch&quot;, &quot;status&quot;: &quot;green&quot;, &quot;timed_out&quot;: false, &quot;number_of_nodes&quot;: 1, &quot;number_of_data_nodes&quot;: 1, &quot;active_primary_shards&quot;: 0, &quot;active_shards&quot;: 0, &quot;relocating_shards&quot;: 0, &quot;initializing_shards&quot;: 0, &quot;unassigned_shards&quot;: 0&#125; status字段指示着当前集群在总体上是否正常工作.他有三种颜色含义如下: green: 所有的主分片和副本分片都正常运行 *yellow** 所有的主分片都正常运行,但不是所有的副本分片都正常运行 *red** 有主分片没有正常运行 参考博文[1] Elasticsearch: 权威指南","categories":[{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://zhuxv.github.io/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://zhuxv.github.io/tags/Elasticsearch/"},{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://zhuxv.github.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"}],"author":"Zhu Xv"},{"title":"负载均衡及高并发","slug":"负载均衡及高并发","date":"2020-11-20T06:53:40.000Z","updated":"2020-11-20T07:30:01.219Z","comments":true,"path":"2020/11/20/负载均衡及高并发/","link":"","permalink":"https://zhuxv.github.io/2020/11/20/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8F%8A%E9%AB%98%E5%B9%B6%E5%8F%91/","excerpt":"负载均衡及高并发负载均衡及高并发相关问题及试题","text":"负载均衡及高并发负载均衡及高并发相关问题及试题 如何处理负载,高并发 HTML静态化效率最高,消耗最小的就是纯静态化的html页面,所以我们尽可能使我们的网站上的页面采用静态化页面来实现, 这个最简单的方法也是最有效的方法. 图片服务器分离出来把图片单独存储,尽量减少图片等大流量的开销, 可以放在一些相关平台. 数据库集群和库表散列及缓存数据库的并发连接为100, 一台数据库远远不够,可以从读写分离,主从复制,数据库集群方面来着手.尽量减少数据库的访问,可以使用缓存数据库如memcache,redis 镜像尽量减少下载,可以把不同的请求分发到多个镜像端 负载均衡apache的最高并发连接为1500,只能增加服务器,可以从硬件着手,如F5服务器,当然硬件的成本比较高,我们往往从软件着手负载均衡(Load Balancing) 建立在现有的网络结构之上, 他提供了一种廉价有效透明的方法扩展网络设备和服务器带宽,增加吞吐量,加强网络数据处理能力,同时能够提高网络的灵活性和可用性.目前使用最广泛的负载均衡软件 nginx, lvs, haproxy三种负载均衡的优缺点NGINX: 优点: 工作在网络的7层之上,可以针对http应用做一些分流策略","categories":[{"name":"并发","slug":"并发","permalink":"https://zhuxv.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"负载均衡","slug":"负载均衡","permalink":"https://zhuxv.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"高并发","slug":"高并发","permalink":"https://zhuxv.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"author":"Zhu Xv"},{"title":"算法试题","slug":"算法试题","date":"2020-11-20T03:01:01.000Z","updated":"2020-11-25T05:25:38.162Z","comments":true,"path":"2020/11/20/算法试题/","link":"","permalink":"https://zhuxv.github.io/2020/11/20/%E7%AE%97%E6%B3%95%E8%AF%95%E9%A2%98/","excerpt":"PHP算法","text":"PHP算法 约瑟夫环问题,猴子选大王一群猴子排成一排,按1,2…n依次编号.然后从第1只开始数,数到第m只,把他踢出圈,从他后面在开始数,在数到m只,再把它踢出去…如此循环,直到最后剩下一只猴子为止,那只猴子就叫做大王 123456789101112131415/** * @param string $string * @return string */function mk($n, $m)&#123; $arr = range(1, $n); //构造一个数组 $i = 1; // 第一个 while(count($arr)&gt;1) &#123; //如果总数大于1 ($i%$m!=0) &amp;&amp; array_push($arr, $arr[$i-1]); // 不被踢出则压入尾部 unset($arr[$i-1]); // 压入数组然后删除 $i++; //继续循环 &#125; return $arr[$i-1]; // 直到剩下最后一个大王&#125; 参考博文[1] 面试10家公司，收获9个offer，2020年PHP 面试问题","categories":[{"name":"算法","slug":"算法","permalink":"https://zhuxv.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"},{"name":"算法","slug":"算法","permalink":"https://zhuxv.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"Zhu Xv"},{"title":"APACHE篇","slug":"APACHE篇","date":"2020-11-19T05:32:12.000Z","updated":"2020-11-19T05:32:12.135Z","comments":true,"path":"2020/11/19/APACHE篇/","link":"","permalink":"https://zhuxv.github.io/2020/11/19/APACHE%E7%AF%87/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"常见的几种WEB攻击-CSRF","slug":"常见的几种WEB攻击-CSRF","date":"2020-10-15T05:56:20.000Z","updated":"2020-11-18T06:56:56.879Z","comments":true,"path":"2020/10/15/常见的几种WEB攻击-CSRF/","link":"","permalink":"https://zhuxv.github.io/2020/10/15/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8DWEB%E6%94%BB%E5%87%BB-CSRF/","excerpt":"什么是CSRFCross Site Request Forgery 跨站域请求伪造 是一种网络攻击方式, 它在 2007 年曾被列为互联网 20 大安全隐患之一, 也被称为 One Click Attack 或者 Session Riding, 通常缩写为 CSRF 或 XSRF, 是一种对网站的恶意利用. 尽管听起来像跨站脚本 XSS, 但是他与 XSS 非常不同, 并且攻击方式几乎相左. XSS 利用站点内的信任用户, 而 CSRF 则通过 伪装来自受信任用户 的请求来利用受信任网站. 与 XSS 相比, CSRF 攻击往往不太流行(因此对其进行防范的资源也相当稀少)和难以防范, 所以被认为比 XSS 更具有危险性.","text":"什么是CSRFCross Site Request Forgery 跨站域请求伪造 是一种网络攻击方式, 它在 2007 年曾被列为互联网 20 大安全隐患之一, 也被称为 One Click Attack 或者 Session Riding, 通常缩写为 CSRF 或 XSRF, 是一种对网站的恶意利用. 尽管听起来像跨站脚本 XSS, 但是他与 XSS 非常不同, 并且攻击方式几乎相左. XSS 利用站点内的信任用户, 而 CSRF 则通过 伪装来自受信任用户 的请求来利用受信任网站. 与 XSS 相比, CSRF 攻击往往不太流行(因此对其进行防范的资源也相当稀少)和难以防范, 所以被认为比 XSS 更具有危险性. CSRF可以做什么你可以这么理解 CSRF 攻击, 攻击者盗用了你的身份, 以你的名义发送恶意请求. CSRF 能够做的事情包括: 以你的名义发送邮件,发送消息,盗取你的账号,甚至购买商品,虚拟货币转账…… 造成的问题包括: 个人隐私泄露以及财产安全 原理 登录受信任网站A, 并在本地生成 Cookie 在不登出A的情况下, 访问危险网站B.看到这里, 你也许会说: “如果我不满足以上两个条件中的一个,我就不会受到 CSRF 的攻击”. 是的, 确实如此, 但你不能保证以下情况不会发生: 你不能保证你登陆了一个网站后, 不在打开一个 tab 页面并访问另外的网站. 你不能保证你关闭浏览器后, 你本地 Cookie 会立刻过期, 你上次的会话已经结束. (事实上, 关闭浏览器不能结束一个会话) 所谓的攻击网站, 也可能是一个存在其他漏洞的可信任的经常被人访问的网站详细的原理介绍几种常见的攻击类型GET类型的CSRF这种类型的 CSRF 一般是由于程序员安全意识不强造成的. GET类型的 CSRF 利用非常简单, 只需要一个HTTP请求, 所以一般会这样利用:1&lt;img src=&quot;http://test.com/csrf?xx=11&quot; /&gt; 在访问含有这个 img 的页面后, 成功向 http://test.com/csrf?xx=11 发送了一次请求. 所以, 如果将该网址替换为存在GET型 CSRF 的地址,就能完成攻击了.例子: 假设某游戏网站的虚拟币转账是采用GET方式进行操作的 1http:&#x2F;&#x2F;www.game.com&#x2F;Transfer.php?toUserId&#x3D;11&amp;vMoney&#x3D;1000 此时恶意攻击者的网站也构建一个相似的链接可以是采用图片隐藏, 页面一打开就自动进行访问第三方文章: 1&lt;img src=&#x27;攻击链接&#x27;&gt; 也可以采用js进行相应的操作 1http:&#x2F;&#x2F;www.game.com&#x2F;Transfer.php?toUserId&#x3D;20&amp;vMoney&#x3D;1000 #toUserID为攻击的账号ID 假如客户端已经验证并登陆 www.game.com 网站, 此时客户端浏览器保存了游戏网站的验证 cookie 客户端在 tab 另一个页面进行访问恶意攻击者的网站, 并从恶意攻击者的网站构造的链接来访问游戏网站 浏览器将会携带该游戏网站的 cookie 进行访问 POST类型的CSRF这种类型的 CSRF 危害没有GET型的大, 利用起来通常使用的是一个自动提交的表单, 如:1234&lt;form action=http://test.com/csrf.php method=POST&gt;&lt;input type=&quot;text&quot; name=&quot;xx&quot; value=&quot;11&quot; /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 访问该页面后, 表单会自动提交, 相当于模拟用户完成了一次POST操作CSRF防御方法服务器端防御: 重要数据交互采用POST进行接收,当然POST也不是万能的,伪造一个form表单即可破解 使用验证码作为辅助工具 验证HTTP Referer字段, 该字段记录了此次HTTP请求的来源地址, 最常见的是图片防盗链. PHP中可以采用 Apache URL重写规则进行防御 为每个表单增加令牌token验证(前提是先解决好XSS攻击, 否则也是白忙一场) CSRF攻击之所以能够成功,是因为攻击者可以伪造用户的请求,该请求中所有的用户验证信息都存于 COOKIE 中,因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的cookie来通过安全验证.由此可知, 抵御CSRF的关键在于:请求中放入攻击者不能伪造的信息, 并且该信息不存在与cookie中 参考博文[1] 浅谈CSRF[2] CSRF攻击与防御","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://zhuxv.github.io/categories/WEB%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://zhuxv.github.io/tags/WEB/"},{"name":"安全","slug":"安全","permalink":"https://zhuxv.github.io/tags/%E5%AE%89%E5%85%A8/"},{"name":"CSRF","slug":"CSRF","permalink":"https://zhuxv.github.io/tags/CSRF/"}],"author":"Zhu Xv"},{"title":"常见的几种WEB攻击-DDOS","slug":"常见的几种WEB攻击-DDOS","date":"2020-10-15T01:54:47.000Z","updated":"2020-10-15T03:58:14.534Z","comments":true,"path":"2020/10/15/常见的几种WEB攻击-DDOS/","link":"","permalink":"https://zhuxv.github.io/2020/10/15/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8DWEB%E6%94%BB%E5%87%BB-DDOS/","excerpt":"DDOS什么是DDOS全称 Distributed Denial of Service, 中文意思为 “分布式拒绝服务”, 就是利用大量合法的分布式服务器对目标发送请求, 从而导致正常合法用户无法获得服务. 通俗点讲就是利用网络节点资源如: IDC服务器, 个人PC, 手机, 智能设备, 打印机, 摄像头等对目标发起大量攻击请求, 从而导致服务器拥塞而无法对外提供正常服务","text":"DDOS什么是DDOS全称 Distributed Denial of Service, 中文意思为 “分布式拒绝服务”, 就是利用大量合法的分布式服务器对目标发送请求, 从而导致正常合法用户无法获得服务. 通俗点讲就是利用网络节点资源如: IDC服务器, 个人PC, 手机, 智能设备, 打印机, 摄像头等对目标发起大量攻击请求, 从而导致服务器拥塞而无法对外提供正常服务 黑客为什么选择DDOS不同于其他恶意篡改数据或劫持类攻击, DDoS 简单粗暴, 可以达到直接摧毁目标的目的. 另外, 相对其他攻击手段 DDoS 的技术要求和发动攻击的成本很低, 只需要够买部分服务器权限或控制一批肉鸡即可, 而且攻击相应速度很快, 攻击效果可视. 另一方面, DDoS 具有攻击易防守难的特征, 服务提供商为了保证正常客户的需求需要耗费大量的资源才能和攻击发起方进行对抗. 这些特点使得 DDoS 成为黑客们手中的一把很好使的利剑.从另一方面, DDoS 虽然可以侵蚀宽带或资源, 迫使服务中断, 但这远远不是黑客的真正目的. 所谓没有买卖就没有杀害, DDoS 只是黑客手中的一枚核武器, 他们的目的要么是敲诈勒索, 要么是商业竞争, 要么就是表达政治立场, 在这种黑色利益的驱使下, 越来越多的人参与到这个行业并对攻击手段进行改进升级, 致使 DDoS 在互联网行业愈演愈烈, 并成为全球范围内无法攻克的一个顽疾 DDoS的攻击方式资源消耗类攻击资源消耗类是比较典型的 DDoS 攻击, 最具代表性的包括: Syn Flood, Ack Flood, UDP Flood. 这类攻击的目标简单, 就是通过大量请求消耗正常的宽带和协议栈处理资源的能力, 从而达到服务端无法正常工作的目的. 服务消耗性攻击相比资源消耗类攻击, 服务消耗类攻击不需要太大的流量, 他主要是针对服务的特点进行精确定点打击, 如 WEB 的 CC, 数据服务的检索, 文件服务的下载等. 这类攻击往往不是为了拥塞流量通道或协议处理通道, 他们是让服务端始终处理高消耗型的业务的忙碌状态, 进而无法对正常业务进行响应 反射类攻击反射攻击也叫放大攻击, 该类攻击以 UDP 协议为主, 一般请求回应的流量远远大于请求本身流量的大小. 攻击者通过流量被放大的特点以较小的流量宽带就可以制造出大规模的流量源, 从而对目标发起攻击. 反射类攻击严格意义上来说不算是攻击的一种, 他只是利用某些服务的业务特征来实现用更小的代价发动 Flood 攻击 混合型攻击混合型攻击是结合上述几种攻击类型, 并在攻击过程中进行探测选择最佳的攻击方式. 混合型攻击往往伴随这资源消耗和服务消耗两种的攻击特征 DDoS防护困难一方面在过去的几十年中, 网络基础设施核心部件从未改变, 这使得一些已经发现和被利用的漏洞以及一些成熟的攻击工具生命周期很长, 即使放到今天也依然有效. 另一方面, 互联网七层模型应用的迅猛发展, 使得 DDoS 的攻击目标多元化, 从 web 到 DNS, 从三层网络到七层应用, 从协议栈到应用 App, 层出不穷的新产品也给了黑客更多的机会和突破点. 在者 DDoS 的防护是一个技术和成本不对等的工程, 往往一个业务的 DDoS 防御系统建设成本要比业务本身的成本或收益更加庞大, 这使得很多创业公司或小型互联网公司不愿意做更多的投入. DDoS防护手段资源隔离资源隔离可以看做是用户服务的一堵防护盾, 这套防护系统拥有无比强大的数据和流量处理能力, 为用户过滤异常流量和请求. 如: 针对 Syn Flood, 防护盾会响应 Syn Cookie 或 Syn Reset 认证, 通过对数据源的认证, 过滤伪造源数据包或发动的攻击, 保护服务端不受恶意连接的侵蚀. 资源隔离系统主要是针对 ISO 模型的第三层和第四层进行防护 用户规则从服务的角度来说 DDoS 防护本质上是一场已用户为主体依赖抗D防护系统与黑客进行较量的战争, 在整个数据对抗过程中服务提供者往往具有绝对的主动权, 用户可以基于抗D系统特定的规则, 如: 流量类型, 请求频率, 数据包特征, 正常业务之间的延长时间间隔等. 基于这些规则用户可以再满足正常服务本身的前提下更好的对抗七层类的 DDoS, 并减少服务端的资源开销 大数据智能分析黑客为了构造大量的数据流, 往往需要通过特定的工具来构造请求数据, 这些数据包不具有正常用户的一些行为特征. 为了对抗这种攻击, 可以基于对海量数据进行分析, 进而对合法用户进行模型化, 并利用这些指纹特征, 如: HTTP 模型特征, 数据来源, 请求源等, 有效的对请求源进行白名单过滤, 从而实现对 DDoS 流量的精确清洗 资源对抗资源对抗也叫 “死扛”, 即通过大量服务器和宽带资源的堆砌达到从容应对 DDoS 流量的效果 参考博文[1] 什么是DDOS攻击","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://zhuxv.github.io/categories/WEB%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://zhuxv.github.io/tags/WEB/"},{"name":"安全","slug":"安全","permalink":"https://zhuxv.github.io/tags/%E5%AE%89%E5%85%A8/"},{"name":"DDOS","slug":"DDOS","permalink":"https://zhuxv.github.io/tags/DDOS/"}],"author":"Zhu Xv"},{"title":"常见的几种WEB攻击-XSS","slug":"常见的几种WEB攻击-XSS","date":"2020-09-29T09:43:26.000Z","updated":"2020-10-15T02:09:52.963Z","comments":true,"path":"2020/09/29/常见的几种WEB攻击-XSS/","link":"","permalink":"https://zhuxv.github.io/2020/09/29/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8DWEB%E6%94%BB%E5%87%BB-XSS/","excerpt":"搞Web开发离不开安全这个话题，确保网站或者网页应用的安全性，是每个开发人员都应该了解的事。","text":"搞Web开发离不开安全这个话题，确保网站或者网页应用的安全性，是每个开发人员都应该了解的事。 XSS攻击什么是XSS攻击XSS 即(Cross Site Scripting) 中文名称为: 跨站脚本攻击 XSS的重点不在于跨站点, 而在于脚本的执行. 那么XSS的原理是:恶意攻击者在 web 页面中会插入一些恶意的 script 代码. 当用户浏览该网页的时候, name嵌入到 web 页面中 script 代码会执行, 因此会达到恶意攻击的目的. 那么 XSS 攻击最主要有如下分类: 反射型, 存储型以及 DOM-based 型. 反射型和 DOM-based 型可以归类为非持久性 XSS 攻击. 存储型可以归类为持久性 XSS 攻击 cookie 安全策略在服务器端设置 cookie 的时候设置 http-only, 这样就可以防止用户通过 JS 获取 cookie设置: http-only: 只允许 http 或 https 请求读取 cookie, JS 代码是无法读取 cookie 的. 发送请求时自动发送 cookie.secure-only: 只允许 https 请求读取, 发送请求时自动发送 cookiehost-only: 只允许主机域名与 domain 设置完成一致的网站才能访问该 cookie X-XSS-Protection 设置目前该属性被所有的主流浏览器默认开启 XSS 保护. 该参数是设置在响应头中目的是用来防范 XSS 攻击的. 他有如下几种配置: 默认为 1. 0: 禁用 XSS 保护1: 启用 XSS 保护1; mode=block; 启用 XSS 保护, 并且在检查到 XSS 攻击时, 停止页面渲染 XSS 防御 HTML 编码我们需要将不可信数据放入到 html 标签内的时候需要进行 html 编码编码规则: 将 &amp;&lt;&gt;”‘/ 转义为实体字符. XSS 防御 HTML Attribute 编码和 HTML 编码一样, html 中的属性也要进行编码, 比如 &lt;input name=&quot;name&quot; /&gt;, name 是 input 的属性, 因此在 html 解析时, 会对 name 属性进行编码, 因为假如 {name} 的值为: &quot; onclick=&quot;alert(&#39;属性XSS&#39;)&quot; &quot;这样的, input 就变成了: &lt;input name=&quot;&quot; onclick=&quot;alert(&#39;属性XSS&#39;)&quot; &quot;&quot; /&gt;. input 属性 name 被插入了 onclick 事件, 因此对于常规的 html 属性, 都需要对其进行 HTML 属性编码.编码规则: 除了字母, 数字, 字符以外, 使用 &#x;16进制格式来转义 ASCII 值小于 256 以外的所有字符 javascript 编码在上面的 XSS 防御 HTML Attribute 编码中我们是可以防御 XSS 攻击, 但是他只能防御的是 HTML 的通用属性, 并不是全部属性, 在 html 中还存在很多支持协议解析的 html 属性, 比如 onclick, onerror, href, src 等这些, 类似这些属性我们是无法通过 HTML 编码来防范 XSS 攻击的. 因为浏览器会先解析 html 编码的字符, 将其转换为该属性的值, 但是该属性本身支持 JS 代码执行, 因此浏览器在 HTML 解码后, 对该属性的值进行 JS 解析, 因此会执行响应的代码.JavaScript 编码将字符编码成 \\x+16 进制的形式, 对字节编码成 Unicode URL 编码作用范围: 将不可信数据作为 URL 参数值时需要对参数进行 URL 编码编码规则: 将参数值进行 encodeURLComponent 编码 CSS 编码作用范围: 将不可信数据作为 CSS 时进行 CSS 编码编码规则: 除了数字字母字符以外, 使用 \\XXXXXX 格式来转义 ASCII 值小于 256 的所有字符. 开启 CSP 网页安全政策防止 XSS 攻击Content-Security-Policy 中文的意思是 网页安全策略, CSP 是网络安全策略的缩写. 主要用来防止 XSS 攻击. 是一种由开发者定义的安全性政策申明, 通过 CSP 所约束的责任指定可信的内容来源, 通过 Content-Security-Policy 网页的开发者可以控制整个页面中 外部资源 的加载和执行.比如可以控制哪些域名下的静态资源可以被页面加载, 哪些不能被加载. 这样就可以很大程度的防范了来自跨站的脚本攻击使用方法: 12345&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot; default-src http: https: *.xxx.com &#x27;self&#x27; &#x27;unsafe-inline&#x27; ; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; *.yyy.com; script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;unsafe-eval&#x27; ;&quot;&gt; 有如下类别: default-src 给下面所有的规则设定一个默认值script-src 外部脚本: unsafe-inline 允许执行页面的内嵌的 &lt;script&gt; 标签和事件监听函数 unsafe-eval 允许将字符串当做代码执行, 比如使用 eval, setTimeout, setInterval 和 Function 函数 nonce 每次 HTTP 回应给出一个授权 token, 页面内嵌脚本必须有 token, 才会执行 hash 列出允许执行的脚本代码的 HASH 值, 页面内嵌脚本的哈希值只有吻合的情况下, 才能执行style-src 样式表img-src 图像media-src 媒体文件font-src 字体文件object-src 插件(如: Flash)child-src 框架frame-ancestors 嵌入外部资源, 比如, connect-src HTTP连接 (通过 XHR, WebSockets, EventSource 等)worker-src worker脚本manifest-src manifest文件 参考博文[1] web安全之XSS攻击原理及防范","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://zhuxv.github.io/categories/WEB%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://zhuxv.github.io/tags/WEB/"},{"name":"安全","slug":"安全","permalink":"https://zhuxv.github.io/tags/%E5%AE%89%E5%85%A8/"},{"name":"XSS","slug":"XSS","permalink":"https://zhuxv.github.io/tags/XSS/"}],"author":"Zhu Xv"},{"title":"常见的几种WEB攻击-SQL注入","slug":"常见的几种WEB攻击-SQL注入","date":"2020-09-29T09:43:26.000Z","updated":"2020-10-15T02:54:38.606Z","comments":true,"path":"2020/09/29/常见的几种WEB攻击-SQL注入/","link":"","permalink":"https://zhuxv.github.io/2020/09/29/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8DWEB%E6%94%BB%E5%87%BB-SQL%E6%B3%A8%E5%85%A5/","excerpt":"SQL注入什么是SQL注入SQL 注入是通过客户端的输入把 SQL 命令注入到一个应用的数据库中, 从而执行恶意的 SQL 语句.","text":"SQL注入什么是SQL注入SQL 注入是通过客户端的输入把 SQL 命令注入到一个应用的数据库中, 从而执行恶意的 SQL 语句. SQL 被攻击的原因是: sql 语句伪造参数, 然后对参数进行拼接后形成 xss 攻击的 sql 语句. 最后导致数据库被攻击了 注意: 但凡有 SQL 注入漏洞的程序, 都是因为程序要接受来自客户端用户输入的变量或 URL 传递的参数, 并且这个变量或参数是组成 SQL 语句的一部分, 对于用户输入的内容或传递的参数, 我们应该要时刻保持警惕, 这里安全领域里的 [外部数据不可信任] 的原则, 纵观 WEB 安全领域的各种攻击方式, 大多数都是因为开发者违反了这个原则而导致的, 所以自然能想到的, 就是从变量的检测, 过滤, 验证下手, 确保变量是开发者所预想的 防范方法: 我们可以使用预编译语句(PreparedStatement), 这样的话即使我们使用 sql 语句伪造参数, 到了服务端的时候, 这个伪造 sql 语句的参数也只是简单的字符串, 并不能起到攻击的作用数据库中的密码不明文存储, 可以对密码进行 md5 加密, 为了加大破解成本, 可以采用加盐的方式只要有固定格式的变量, 在 SQL 语句执行前, 应该严格按照固定格式去检查, 确保变量是我们预想的格式, 这样可以很大程度上避免 SQL 注入 什么是预编译通常我们的一条 SQL 在 db 接收到最终执行完毕返回可以分为下面三个过程 词法和语义解析 优化 sql 语句, 制定执行计划 执行并返回结果 我们把 这种普通语句称作 Immediate Statements.但是很多情况下, 我们的一条 sql 语句可能会反复执行, 或者每次执行的时候只有个别的值不同.如果每次都需要经过上面的词法语义解析, 语句优化, 指定执行计划, 则效率明显就不行了.所谓预编译语句就是将这类语句中的值用占位符代替, 可以视为将 sql 语句模板化或者参数化, 一般称这类语句叫 Prepared Statements 或者 Parameterized Statements预编译语句优势在于: 一次编译, 多次运行, 省去了解析优化等过程; 此外预编译能够防止 sql 注入 防止SQL注入 永远不要信任用户的输入, 对用户的输入进行校验, 可以通过正则表达式, 或限制长度; 对单双引号进行转换 永远不要使用动态拼接 SQL, 可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取 永远不要使用管理员权限的数据库连接, 为每个应用使用单独的权限有限的数据库连接 不要把机密信息直接存放, 加密或者 hash 掉密码和敏感信息 应用的异常信息应该给出尽可能少的提示, 最好使用自定义的错误信息对原始错误信息进行包装 PHP 在MySQL 扩展提供了 mysqli_real_escape_string() 函数来转义特殊的输入字符, addcslashes() 函数在指定字符前增加反斜杠 参考博文[1] MySQL及SQL注入","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://zhuxv.github.io/categories/WEB%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://zhuxv.github.io/tags/WEB/"},{"name":"安全","slug":"安全","permalink":"https://zhuxv.github.io/tags/%E5%AE%89%E5%85%A8/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://zhuxv.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}],"author":"Zhu Xv"},{"title":"RESTfulAPI的理解及其原理","slug":"RESTfulAPI的理解及其原理","date":"2020-09-29T08:52:55.000Z","updated":"2020-10-15T05:48:49.390Z","comments":true,"path":"2020/09/29/RESTfulAPI的理解及其原理/","link":"","permalink":"https://zhuxv.github.io/2020/09/29/RESTfulAPI%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/","excerpt":"RESTful架构, 就是目前最流行的一种互联网软件架构. 他结构清晰, 符合标准, 易于理解, 扩展方便, 所以正得到越来越多的网站采用","text":"RESTful架构, 就是目前最流行的一种互联网软件架构. 他结构清晰, 符合标准, 易于理解, 扩展方便, 所以正得到越来越多的网站采用 RESTful API 的理解及其原理REST, 即 Representational State Transfer 的缩写. 我对这个词组的翻译是 “表现层状态转化”.如果一个架构符合 REST 原则, 就称他为 RESTful 架构 资源(Resources)REST的名称 表现层状态转化 中, 省略了主语. 表现层 其实指的就是 资源 Resources 的 表现层所谓 资源, 就是网络上的一个实体, 或者说是网络上的一个具体信息. 他可以是一段文本, 一张图片, 一首歌曲, 一种服务, 总之就是一个具体的实在. 你可以用一个 URI 统一资源定位符 指向他, 每种资源对应一个特定的 URI. 要获取这个资源, 访问他的 URI 就可以, 因此 URI 就成了每个资源的地址或独一无二的标识符所谓 上网, 就是与互联网上一系列的 资源 互动, 调用他的 URI 表现层(Representation)资源 是一种信息实体, 他可以有多种外在表现形式. 我们把 资源 具体呈现出来的形式, 叫做他的 表现层 Representation比如: 文本可以用 txt 格式表现, 也可以用 HTML 格式, XML 格式, JSON 格式表现, 甚至可以采用二进制格式; 图片可以用 JPG 格式表现, 也可以用 PNG 格式表现.URL 只代表资源的实体, 不代表他的形式. 严格的说, 有些网址最后的 “.html” 后缀名是不必要的, 因为这个后缀表示格式, 属于 表现层 的范畴, 而 URI 应该只代表 资源 的位置. 他的具体表现形式, 应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定, 这两个字段才是对 表现层 的描述. 状态转化(State Transfer)访问一个网站, 就代表了客户端和服务器的一个互动过程. 在这个过程中, 势必涉及到数据和状态的变化.互联网通信协议 HTTP 协议, 是一个无状态协议. 这意味着, 所有的状态都保存在服务器端. 因此, 如果客户端想要操作服务器, 必须通过某种手段, 让服务端发生 状态转化 State Transfer. 而这种转化是建立在表现层之上的, 所以就是 表现层状态转化.客户端用到的手段, 只是 HTTP 协议. 具体来说, 就是 HTTP 协议里面, 四个表示操作方式的动词: GET, POST, PUT, DELETE. 他们分别对应四种基本操作: GET 用来获取资源, POST 用来新建资源, PUT 用来更新资源, DELETE 用来删除资源. 综述综合上面的解释, 我们总结一下什么是 RESTful 架构: (1) 每一个 URI 代表一种资源;(2) 客户端和服务端之间, 传递这种资源的某种表现层;(3) 客户端通过四个 HTTP 动词, 对服务端资源进行操作, 实现 表现层状态转化. 误区最常见的一种设计错误, 就是 URI 包含动词. 因为 资源 表示一种实体, 所以应该是名词, URI 不应该有动词, 动词应该放在 HTTP 协议中.另一种设计误区, 就是在 URI 中加入版本号. 因为不同的版本, 可以理解成同一种资源的不同表现形式, 所以应该采用同一个 URI. 版本号可以在 HTTP 请求头信息的 Accept 字段中进行区分 参考博文[1] 理解RESTful架构","categories":[{"name":"架构","slug":"架构","permalink":"https://zhuxv.github.io/categories/%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"架构","slug":"架构","permalink":"https://zhuxv.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"RESTful","slug":"RESTful","permalink":"https://zhuxv.github.io/tags/RESTful/"}],"author":"Zhu Xv"},{"title":"MVC模式","slug":"MVC模式","date":"2020-09-29T08:22:44.000Z","updated":"2020-10-15T09:24:04.474Z","comments":true,"path":"2020/09/29/MVC模式/","link":"","permalink":"https://zhuxv.github.io/2020/09/29/MVC%E6%A8%A1%E5%BC%8F/","excerpt":"如何设计一个程序的结构, 这是一门专门的学问, 叫做架构模式, 属于编程的方法论.MVC 模式就是架构模式的一种","text":"如何设计一个程序的结构, 这是一门专门的学问, 叫做架构模式, 属于编程的方法论.MVC 模式就是架构模式的一种 MVC是三个单词的首字母缩写, 他们是 Model(模型), View(视图)和Controller(控制器)这个模式认为, 程序不论简单或复杂, 从结构上看, 都可以分为三层: 最上面的一层, 是直接面向最终用户的视图层(View). 他是提供给用户的操作界面, 是程序的外壳 最底下的一层, 是核心的数据层(Model). 也就是程序需要操作的数据或信息 中间的一层, 就是控制层(Controller), 他是根据用户从视图层输入的指令, 选取数据层中的数据, 然后对其进行相应的操作, 产生最终的结果 这三层是紧密联系在一起的, 但又是相互独立的, 每一层内部的变化不影响其它层. 每一层都对外提供接口(Interface), 供上面一层调用. 这样一来, 软件就可以实现模块化, 修改外观或者变更数据都不用修改其它层, 大大方便了维护和升级 参考博文[1] 谈谈MVC模式","categories":[{"name":"MVC","slug":"MVC","permalink":"https://zhuxv.github.io/categories/MVC/"}],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://zhuxv.github.io/tags/MVC/"}],"author":"Zhu Xv"},{"title":"PHP练习题-REDIS篇","slug":"PHP练习题-REDIS篇","date":"2020-09-27T08:16:51.000Z","updated":"2020-11-20T05:36:00.364Z","comments":true,"path":"2020/09/27/PHP练习题-REDIS篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/27/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-REDIS%E7%AF%87/","excerpt":"REDIS篇REDIS 练习笔记","text":"REDIS篇REDIS 练习笔记 1.redis和memcached相比有哪些优势memcached 所有的值均是简单的字符串, redis 做为其代替者, 支持更丰富的数据类型 redis 的速度比 memcached 快很多 redis 可以持久化其数据 2.redis是单线程redis 利用队列技术将并发访问变成串行访问, 消除了传统数据库串行控制的开销 3.redis的五种数据类型string, list, set, sorted set, hash 4.redis的并发竞争问题如何解决单线程单进程模式, 采用队列模式将并发访问改为串行访问. redis 本身没有锁的概念, redis 对于多个客户端连接不存在竞争, 利用 setnx 实现锁 5.redis启动命令./redis-server 6.redis 支持的语言Java, C, C#, C++, PHP, Node.js GO 等 7.redis 持久化解决方案RDB RDB 持久化是把当前进程数据生成快照保存到硬盘的过程, 触发 RDB 持久化过程分为手动触发和自动触发 RDB 完成后会自动生成一个文件, 保存在 dir 配置的指定目录下, 文件名是 dbfilename 指定 REDIS 默认会采用 LZF 算法对生成的 RDB 文件做压缩处理, 压缩后的文件远远小于内存大小, 默认开启 手动触发: 手动触发的命令有 save 和 bgsave save: 该命令会阻塞 Redis 服务器, 直到 RDB 的过程完成, 已经被废弃, 因此线上不建议使用 bgsave: 每次进行 RDB 过程都会 fork 一个子进程, 由子进程完成 RDB 操作, 因此阻塞只会发生在 fork 阶段, 一般时间很短 自动触发: (1) 根据我们的 save m n 配置规则自动触发 (2) 如果从节点执行全量复制操作, 主节点自动执行 bgsave 生成 RDB 文件并发送给从节点 (3) 执行 debug reload 命令重新加载 Redis 时, 也会触发 save 操作 (4) 默认情况下执行 shutdown 命令时, 如果没有开启 AOF 持久化功能则自动执行 bgsave 优点: RDB 是一个紧凑的压缩的二进制文件, 代表 Redis 在某个时间点上的数据快照. 非常适用与备份, 全量复制等场景. 比如每六个小时执行 bgsave 备份, 并把 RDB 文件拷贝到远程机器或者文件系统中, 用于灾难恢复 Redis 加载 RDB 恢复数据远远快于 AOF 的方式 缺点: RDB 方式数据没办法做到 实时持久化/秒级持久化. 因为 bgsave 每次运行都要执行 fork 操作创建子进程, 属于重量级操作, 频繁执行成本太高 RDB 文件使用特定的二进制格式保存, Redis 版本演进过程中有多个格式 RDB 版本, 存在老版本 Redis 服务无法兼容新版本 RDB 格式问题 AOF(append only file) 以独立日志的方式记录每次写命令, 重启时在重新执行 AOF 文件中的命令达到恢复数据的目的. AOF 的主要作用是解决了数据持久化的实时性, 目前已是 Redis 持久化的主流方式 如何开启AOF 开启 AOF 功能需要设置配置: appendonly yes, 默认不开启. AOF 文件名通过 appendfilename 配置设置, 默认文件名是 appendonly.aof. 保存路径同 RDB 持久化方式一致, 通过 dir 配置指定 优点: 使用 AOF 持久化会让 Redis 变的非常耐久: 你可以设置不同的 fsync 策略, 比如无 fsync, 每秒钟一次 fsync, 或者每次执行写入命令时 fsync. AOF 的默认策略为每秒钟 fsync 一次, 在这种配置下, Redis 仍然能够保持良好的性能, 并且就算发生故障停机, 也最多只会丢失一秒钟数据 缺点: 对于相同的数据集来说, AOF 文件的体积通常要大于 RDB 文件的体积. 根据所使用的 fsync 策略, AOF 的速度可能会慢与 RDB. 在一般情况下, 每秒 fsync 的性能依然非常高, 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快, 即使在高负荷之下也是如此. 不过在处理巨大的写入载入时, RDB 可以提供更有保证的最大延迟时间 数据恢复速度相对于 RDB 比较慢 AOF和RDB的区别 RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘, 实际操作过程是 fork 一个子进程, 先将数据集写入临时文件, 写入成功后, 在替换之前的文件, 用二进制压缩存储 AOF持久化以日志的形式记录服务器所处理的每一个写, 删除操作, 查询操作不会记录, 以文本的方式记录, 可以打开文件看到详细的操作记录 性能和解决方案 通过上面的分析, 我们都知道 RDB 的快照, AOF 的重写都需要 fork, 这是一个重量级操作, 会对 Redis 造成阻塞. 因此为了不影响 Redis 主进程, 我们需要尽可能降低阻塞. 如何减少 fork 操作的阻塞 (1) 优先使用物理机或者高效支持 fork 操作的虚拟化技术 (2) 控制 Redis 实例最大可用内存, fork 耗时跟内存量成正比, 线上建议每个 Redis 实例内存控制在 10G 以内 (3) 合理配置 LINUX 内存分配策略, 避免物理内存不足导致 fork 失败 (4) 降低 fork 操作的频率, 如适度放宽 AOF 自动触发时机, 避免不必要的全量复制等 8.什么是Redis雪崩和穿透缓存穿透当访问redis中一个不存在的key时,会直接穿透过去,去数据库中查询.解决办法:每次从数据库中查询到一个不存在的key的时候,就写一个空值到redis中,查询值为空直接返回 缓存雪崩假设每秒有5000个请求过来的时候,redis缓存库崩了,然后这些请求瞬间落在mysql数据库上,直接导致数据库死机.解决办法: 事前: 提高缓存库的高可用,使用主从结构加哨兵 cluster集群 事中: 使用ehcache+hystrix限流组件(当请求非常大的时候,返回一些默认值或空白值) 事后: 做持久化,尽快恢复缓存集群,一旦恢复,自动从磁盘上读取数据,恢复内存中的数据9.redis消息队列先进先出需要注意什么通常使用一个list来实现队列操作,这样有一个小限制,所有的任务统一都是先进先出,如果想优先处理某些任务就不太好处理了,这就需要让队列有优先级的概念,我们就可以优先处理高级别的任务实现方式: 单一列表:队列正常的操作是左进右出(lpush,rpop), 为了先处理高优先级任务,在遇到高级别任务时,可以直接插队,直接放入队列头部(rpush),这样,从队列头部(右侧)获取任务时,取到的就是高优先级的任务(rpop) 使用两个队列,一个普通队列,一个高级队列,针对任务的级别放入不同的队列,获取任务时也很简单,redis的brpop命令可以按顺序从多个队列中取值,brpop会按照给出的key顺序查看,并在找到的第一个非空list尾部弹出一个元素10.redis如何防止高并发redis本身是不存在高并发的问题, 因为他是单进程的,再多的命令都是一个接着一个执行的Redis为什么会有高并发的问题Redis是一种单线程机制的nosql数据库,基于key-value,数据可持久化落盘. 由于单线程所以Redis本身没有锁的概念,多个客户端连接并不存在竞争关系,但是利用jedis等客户端对redis进行并发访问时会出现问题.发生连接超时,数据转换错误,阻塞,客户端关闭连接等问题,这些问题均是由于客户端连接混乱造成的.同时,单线程的天性决定,高并发对同一个键的操作会排队处理,如果并发量很大的话,可能造成后来的请求超时.在远程访问redis的时候,因为网络等原因造成高并发访问延迟返回的问题解决办法:在客户端将连接进行池化,同时对客户端读写Redis操作采用内部锁synchronized服务器角度,利用setnx变向实现锁机制 参考博文[1] 吐血整理60个Redis面试题,全网最全了[2] 天天用Redis，持久化方案你知道哪些？[2] 面试10家公司，收获9个offer，2020年PHP 面试问题","categories":[{"name":"REDIS","slug":"REDIS","permalink":"https://zhuxv.github.io/categories/REDIS/"}],"tags":[{"name":"REDIS","slug":"REDIS","permalink":"https://zhuxv.github.io/tags/REDIS/"},{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"author":"Zhu Xv"},{"title":"PHP练习题-MySQL篇","slug":"PHP练习题-MySQL篇","date":"2020-09-25T06:17:43.000Z","updated":"2020-11-20T06:52:18.970Z","comments":true,"path":"2020/09/25/PHP练习题-MySQL篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/25/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-MySQL%E7%AF%87/","excerpt":"MySQL篇","text":"MySQL篇 1.MySQL的复制原理及其流程:1.主[binlog线程] 记录下所有改变了数据库数据的语句, 放进 master 上的 binlog 中 2.从[io线程] 在使用 start slave 之后, 负责从 master 上拉取 binlog 内容, 放进自己的 relay log 中 3.从[sql执行线程] 执行 relay log 中的语句 2.MySQL中MyISAM与InnoDB的区别:1 五点不同 (1) InnoDB支持事务, MyISAN不支持事务 (2) InnoDB支持行级锁, MyISAN支持表级锁 (3) InnoDB支持多版本并发控制(MVCC), MyISAN不支持MVCC (4) InnoDB支持外键, MyISAN不支持外键 (5) InnoDB不支持全文索引, 而MyISAN不支持索引 2 InnoDB引擎的4大特征 (1) [插入缓冲(insert buffer)](https://blog.csdn.net/dbanote/article/details/9077113) (2) [二次写(double write)](https://blog.csdn.net/dbanote/article/details/9078091) (3) [自适应哈希索引(ahi)](https://blog.csdn.net/dbanote/article/details/9078129) (4) [预读(read ahead)](https://blog.csdn.net/qq9808/article/details/105846413) 3 MyISAN和InnoDB统计哪个更快 MyISAN更快, 因为MyISAN内部维护了一个计数器 4 MyISAN和InnoDB的选择 (1) 需要支持事务,行级锁,外键选择InnoDB (2) 如果表中没有大量的新增删除修改,对原子性要求低,那么MyISAN是最好的选择(更建议使用nosql) (3) 系统崩溃后MyISAM恢复起来更困难 (4) 高并发建议使用InnoDB 3.MySQL中varchar与char的区别以及varchar(50)中的50代表的含义:1.char是一种固定长度的类型, varchar则是一种可变长度类型 2.varchar(50)中50的含义最多存放50个字符, varchar(50)和varchar(200)存储相同字符串所占空间一样,但是后者在排序时会消耗更多内存, 因为 order by col 采用 fixed_length 长度计算 col 长度(memory引擎也一样) 4.InnoDB事务与日志的实现方式1.有多少种日志 (1) 错误日志: 记录出错信息, 也记录一些警告和正确信息 (2) 查询日志: 记录所有对数据库请求的信息, 不论这些请求是否得到了正确的执行 (3) 慢查询日志: 设置一个阈值, 将运行时间超过该值的查询语句记录到日志中 (4) 二进制日志: 记录对数据库执行更改的所有操作 (5) 中继日志 (6) 事务日志 2.事务的4种隔离级别 (1) 读未提交(RU) (2) 读已提交(RC) (3) 可重复度(RR) (4) 串行 3.事务是如何通过日志来实现的 事务日志是通过 redio 和 innodb 的存储引擎日志缓冲 (Innodb log buffer) 来实现的, 当开始一个事务的时候, 会记录该事物的 isn(log sequence number)号; 当事务执行时, 会往 InnoDB 存储引擎日志的日志缓存里面插入事务; 当事务提交时, 必须将存储引擎的日志缓冲写入磁盘 (通过 innodb_flush_log_at_trx_commit 来控制), 也就是写数据前, 需要先写日志. 这种方式称为 &quot;预写日志方式&quot; 5.MySQL binlog的几种日志录入格式以及区别1.Statement: 每一条会修改数据的 sql 都会记录在 binlog 中 优点: 不需要记录每一行的变化, 减少了 binlog 的日志量, 节约了 IO, 提高了性能 缺点: 由于记录的只是执行语句, 为了这些语句能在 slave 上正确运行, 因此还必须记录每条语句在执行的时候的一些相关信息, 以保证所有语句能在 slave 得到和在 master 端执行时候的相同结果. 另外 mysql 的复制, 像一些特定函数功能, slave 可与 master 上要保持一致会有很多先关问题,比如使用一些函数将会出现一些问题或无法复制的现象 2. Row: 不记录 sql 语句上下文相关信息, 仅保存哪条记录被修改 优点: binlog 中不记录执行 sql 相关上下文信息, 仅需要记录哪一条记录被修改成什么了.所以 rowlevel 的日志内容会非常清楚的记录下每一行的数据修改的细节. 而且不会出现某些特定情况下的存储过程或 function 以及 trigger 的调用和触发无法被正确复制的问题 缺点: 所有的执行语句当记录到日志中的时候, 都将以每行记录的修改来记录, 这样会产生大量的日志内容 3. MixedLevel: 是以上两种级别的混合使用, 一般的语句修改使用 statement 格式保存 binlog, 如一些函数, statement 无法完成主从复制的操作, 则采用 row 格式保存 binlog, MySQL 会根据执行的每一条具体的 sql 语句来区分对待记录的日志形式, 也就是在 Statement 和 Row 之间选择一种, 新版本的 MySQL 中对 row level 模式也被做了优化, 并不是所有的修改都会以 row level 来记录, 像遇到表结构变更的时候就会以 statement 模式来记录. 至于 update 或者 delete 等修改数据的语句, 还是会记录所有行的变更 6.MySQL数据库CPU飙升到500%如何处理1. 列出所有进程 show processlist 观察所有进程, 多秒没有状态变化的 kill 掉 2. 查看超时日志或者错误日志, 一般会是查询以及大批量的插入会导致 CPU 与 I/O 上涨 7.sql优化1. 避免全文扫描, 首先考虑在 where 及 order by 上建立索引 2. 避免在 where 子句中对字段进行 null 判断, 避免使用 != &lt;&gt; 操作符, 避免使用 or 查询 3. in 和 not in 也要慎重使用, 很多时候使用 exists 代替 in 是一个很好的选择 4. 使用 like 时禁止左边模糊查询 5. 在 where 子句中避免对字段进行表达式操作 示例: where num/2=100 应改为 where num=100*2 6. 不要在 where 子句中的等于号 &quot;=&quot; 左边进行函数,算术表达式及其他表达式运算 7. 在使用索引字段作为条件时, 如果该索引是复合索引, 那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引, 否则该索引将不会被使用, 并且应尽可能的让字段顺序与索引顺序保持一致 8. 如果有大量重复数据时,这个字段应该避免建立索引 9. 索引可以提高查询效率, 但同样也可以降低插入和编辑效率, 所以要适量建立索引,一张表最好不超过6个索引 10. 尽量使用数字型字段, 字符型字段会降低查询和连接的性能, 并增加存储开销 11. 尽量使用 varchar 代替 char, 可以节约存储空间, 在一个相对较小的字段内搜索效率显然会更高一些 12. 查询时应该用具体字段代替 * 查询 13. 避免频繁创建临时表和删除临时表, 以减少系统表资源的消耗 14. 临时表并不是不可以使用, 当需要重复引用大型表或常用表中的某个数据集时 15. 在新建临时表时, 如果一次性插入数据量过大, 那么可以使用 select into 代替 create table, 避免造成大量log. 如果数据量不大, 为了缓和表的资源, 应先使用 create table, 然后 insert 16. 如果使用到了临时表, 在存储过程的最后务必将所有的临时表显式删除, 先 truncate table, 然后 drop table, 这样可以避免系统表较长时间锁定 17. 尽量避免使用游标查询, 因为游标查询效率太差, 如果有游标操作的数据超过 1万 行, 那么应该考虑改写 18. 使用游标或者临时表方法之前, 应先寻找基于集的解决方案来解决问题, 基于集的方法通常更有效 19. 尽量避免大事务操作, 提高系统并发能力 20. 尽量避免向客户返回大量数据, 若数据量过大, 应该考虑相应需求是否合理 8.InnoDB的读写参数优化1. innodb_buffer_poor_size: 用于缓冲数据和索引, 对于mysql的性能升级是线性的, 通常对于独立的 MySQL 服务器, innodb_buffer_poor_size最大可设置为内存大小的 70%-80% 计算方法: val = Innodb_buffer_pool_pages_data / Innodb_buffer_pool_pages_total * 100% val &gt; 95% 则考虑增大 innodb_buffer_pool_size， 建议使用物理内存的75% val &lt; 95% 则考虑减小 innodb_buffer_pool_size， 建议设置为：Innodb_buffer_pool_pages_data * Innodb_page_size * 1.05 / (1024*1024*1024) 2. 开启慢查询日志 slow.log, 增加参数: log_queries_not_using_indexes, 所有没有走索引的 sql 语句都会记录到 slow.log 中 3. 提高 query_cache 的命中率 命中率计算方法: Qcache_hits/(Qcache_hits + Qcache_inserts) * 100% 提高 qcache 命中率的方法: 数据动静分离 操作频繁的表和操作不频繁的表分开存放, 数据频繁更改会导致 query_cache 失效 单条 sql 语句的 query_cache 大小是有限制的, 当一条 sql 语句返回的数据大小超过 query_cache_limit 的值时不会缓存,可以适量增加 query_cache_limit 的值. query_cache_size 表示所有 query_cache 的总大小. 当整个数据库的 query_cache 大小超过该值, sql 语句也无法缓存 4. 高并发的情况下建议关闭 query_cache, 不然会有很多的 qcache 锁等待 9.你们的数据库是否支持emoji表情, 如果不支持, 应该怎么做如果是 UTF-8 字符集的话升级至 utf8-mb4 即可 10.表中有大字段x(例如: text类型),且字段x不会经常更新,已读为主,你会选择拆成子表还是放在一起,理由?拆开带来的问题: 连接消耗+存储拆分空间 不拆带来的问题: 查询性能 如果能容忍拆分带来的空间问题: 拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区)顺序IO,减少连接消耗, 最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗 如果能容忍不拆分带来的查询性能损失的话: 上面的方案在某个极致条件下肯定会出现问题, 那么不拆是最好的选择 11.MySQL中InnoDB引擎的行锁是通过加在什么上实现的,为什么InnoDB 是基于索引来完成行锁 例: select * from `table` where id=1 for update; for update 可以根据条件来完成行锁锁定, 并且 id 是有索引键的列, 如果 id 不是索引键, 那么 InnoDB 将完成表锁, 只有在 InnoDB 引擎和事务中才能生效 12.开放性问题:一个6亿的表a, 一个3亿的表b, 通过外键 tid 关联, 你如何最快的查询出满足条件的第 50000-50200 的 200 条数据的记录 1. 如果a表 tid 是自增长的, 并且是连续的, b表的 ID 为索引 select * from a,b where a.tid = b.id and a.tid &gt; 50000 limit 200; 2. 如果a表的 tid 不是连续增长的, 那么就需要使用覆盖索引. tid 要么是主键, 要么是辅助索引, b表 ID 也要有索引 select * from b, (select tid from a limit 50000,200) a where b.id = a.tid 13.单例模式,创建mysqli数据库链接的单例对象Class Db{ private static $instance; public $handle; private function __construct($host, $username, $password, $dbname) &#123; $this-&gt;handle = NULL; $this-&gt;getcon($host, $username, $password, $dbname); &#125; public static function getInstance($host, $username, $password, $dbname) &#123; if (! self::$instance instanceof self) &#123; self::$instance = new self($host, $username, $password, $dbname); &#125; return self::$instance; &#125; private function getcon($host, $username, $password, $dbname) &#123; if ( $this-&gt;handle == NULL ) &#123; $this-&gt;handle = mysqli_connect($host, $username, $password, $dbname); &#125; if ( !$this-&gt;handle ) &#123; die(&#39;连接出错:&#39;.mysql_connect_error()); &#125; // 修改数据库字符集 mysqli_set_charset($this-&gt;handle, &#39;utf-8&#39;); &#125; } 数据库三范式第一范式: 1NF是对属性的原子约束性,要求属性具有原子性,不可在分解第二范式: 2NF是对记录的唯一性约束,要求记录有唯一标识,即实体的唯一性第三范式: 3NF是对字段冗余性的约束,即任何字段不能由其他字段派生出来,他要求字段没有冗余 范式化设计的优缺点:优点: 可以尽量的减少数据冗余,使得更新快,体积小缺点: 对于查询需要多个表进行关联,减少写的效率,增加读的效率,更难进行索引优化 反范式化优点: 可以减少表的关联,可以更好地进行索引优化缺点: 数据冗余以及数据异常,数据得修改需要更多的成本 mysql中有哪几种锁MyISAM支持表锁, InnoDB支持行级锁和表锁,默认为行锁表级锁: 开销小,加锁快,不会出现死锁.锁定力度大,发生锁冲突的概率最高,并发量最低行级锁: 开销大,加锁慢,会出现死锁.力度小,发生锁冲突的概率小,并发度最高 什么是存储过程我们常用的操作数据库语言SQL语句在执行的时候需要先编译,然后执行,而存储过程(Stored Procedure) 是一组为了完成特定功能的SQL语句集,经过编译后存储在数据库中,用户通过制定存储过程的名字并给定参数(如果有参数)来调用执行他一个存储过程是一个可编程的函数,它在数据库中创建并保存.他可以有SQL语句和一些特殊的控制结构组成.当希望在不同的应用程序或平台上执行相同的函数或封装特定的功能时,存储过程是非常有用的.数据库中的存储过程可以看做是对编程中面向对象方法的模拟.它允许控制数据的访问方式优点: 1. 存储过程增强了SQL语句的功能和灵活性.存储过程可以用流控制语句编写,有很强的灵活性,可以完成复杂的判断和较复杂的运算 2. 存储过程允许标准组件是编程.存储过程被创建后,可以再程序中被多次调用,而不必编写该存储过程的SQL语句.而且数据库专业人员可以随时对存储过程进行修改, 对应用程序源代码毫无影响 3. 存储过程能实现较快的执行速度.如果某一操作包含大量的Transaction-SQL代码或者分别被多次执行,那么存储过程要比批量处理的执行速度快很多.因为存储过程是预编译的.在首次运行一个存储过程时查询,优化器对其进行分析优化,并且给出最终被存储在系统表中的执行计划.而批处理的Transation-SQL语句在每次运行都要进行编译和优化,速度相对要慢些 4. 存储过程能够减少网络流量. 针对同一个数据库操作对象(如查询,修改),如果这一操作所涉及的Transation-SQL语句被组织成存储过程,那么当在客户端调用该存储过程时,网络中传送的只是该调用语句,从而大大增加了网络流量并降低了网络负载. 5. 存储过程可被作为一种安全机制来充分利用.系统管理员通过执行某一存储过程的权限进行限制,能够实现对相应的数据的访问权限的限制,避免了非授权用户对数据的访问,保证了数据的安全 参考博文[1] 【MySQL】20个经典面试题[2] sql优化的几种方式[3] 关于mysql innodb引擎性能优化的一点心得","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/categories/MySQL/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/tags/MySQL/"}],"author":"Zhu Xv"},{"title":"apache与nginx的区别","slug":"apache与nginx的区别","date":"2020-09-25T02:06:57.000Z","updated":"2020-11-19T06:09:28.752Z","comments":true,"path":"2020/09/25/apache与nginx的区别/","link":"","permalink":"https://zhuxv.github.io/2020/09/25/apache%E4%B8%8Enginx%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"apache与nginx的区别记录一下apache与nginx的区别, 以便在工作中可以正确选择","text":"apache与nginx的区别记录一下apache与nginx的区别, 以便在工作中可以正确选择 Nginx:1.轻量级, 采用C编写, 同样的web服务, 会占用更少的内存及资源 2.抗并发, 处理请求是异步非阻塞的, 负载能力比 apache 高很多, 而 apache 则是阻塞型的. 在高并发下 nginx 能保持低资源低消耗高性能, 而 apache 在 PHP 处理慢或者前端压力很大的情况下, 很容易出现进程数飙升, 从而拒绝服务现象 3.nginx 处理静态文件好, 静态处理性能是 apache 的三倍以上 4.nginx 的设计高度模块化, 编写模块相对简单 5.nginx 配置简洁, 正则配置让很多事情变得简单, 而且改完配置能使用 nginx -t 测试配置有没有问题, apache 配置复杂, 重启之后发现配置错误,会很崩溃 6.nginx 作为负载均衡服务器, 支持 7 层负载均衡 7.nginx 本身就是一个反向代理服务器, 而且可以作为非常优秀的邮件代理服务器 8.启动特别容易, 并且可以做到 24 小时不断运行, 即使运行数月也不需要重新启动, 还能够不间断服务的情况下进行版本升级 9.社区活跃, 各种高性能模块出品迅速 Apache:1.apache 的 rewrite 比 nginx 强大, 在 rewrite 频繁的情况下, 用 apache 2.apache 发展到现在, 模块超多, 基本想到的都可以找到 3.apache 更为成熟, 少 BUG, nginx BUG 相对比较多 4.apache 非常稳定 5.apache 对 PHP 支持比较简单, nginx 需配合其他后端用 6.apache 在处理动态请求的时候有优势, nginx 在这方面是鸡肋, 一般动态请求要 apache 去做, nginx 适合反向和静态 7.apache 仍然是目前的主流, 拥有丰富的特性, 成熟的技术和开发社区 总结两者最核心的区别在于 apache 是同步多进程模型, 一个连接对应一个进程, 而 nginx 是异步的, 多连接可以对应一个进程一般来说, 需要性能的 web 服务, 用 nginx, 如果不需要性能只要求稳定的服务, 更考虑的是 apache, 后者各种功能模块实现的比前者好, 可配置项多更为通用的方案是, 前端 nginx 抗并发, 后端 apache 集群, 配合起来会更好 参考博文[1] Apache和Nginx的区别","categories":[{"name":"服务","slug":"服务","permalink":"https://zhuxv.github.io/categories/%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"服务","slug":"服务","permalink":"https://zhuxv.github.io/tags/%E6%9C%8D%E5%8A%A1/"}],"author":"Zhu Xv"},{"title":"PHP练习题-基础篇","slug":"PHP练习题-基础篇","date":"2020-09-25T02:00:23.000Z","updated":"2020-11-20T03:54:06.344Z","comments":true,"path":"2020/09/25/PHP练习题-基础篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/25/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"基础篇","text":"基础篇 PHP语言的一大优势是跨平台,什么是跨平台PHP运行环境可以在不同的操作系统(例如: windows, linux等)上配置, 不受操作系统的限制, 所以叫跨平台 什么是面向对象?主要特征是什么?面向对象是程序的一种设计方式,它利于提高程序的重用性,使程序结构更加清晰. 主要特征: 封装,继承,多态. SESSION与COOKIE的区别是什么,请从协议,产生的原因与作用说明 http无状态协议,不能区分用户是否是从同一个网站上来的, 同一个用户请求不同的页面不能看做是同一个用户 SESSION存储在服务端, COOKIE保存在客户端. SESSION比较安全, COOKIE可以随意修改不安全. SESSION依赖于cookie进行传递.禁用COOKIE后,SESSION不能正常使用.SESSION的缺点: 保存在服务器端, 每次读取都从服务器进行读取, 对服务器有资源消耗.SESSION保存在服务器端的文件或数据库中,默认保存在文件中,文件路径由php配置文件的session.save_path指定.SESSION文件是公有地HTTP状态中 302, 403, 500的含义12345原则: 1消息系列.2成功系列.3重定向系列.4请求错误系列.5服务端错误系列302: 临时转移成功,请求的内容已转移到新的位置403: 禁止访问500: 服务错误401: 未授权Linux下建立压缩包,解压压缩包命令tar.gz: 打包: tar czf file.tar.gz file.txt 解压: tar xzf file.tar.gzbz2: 打包: bzip2 [-k] 文件 解压: bunzip2 [-k] 文件gzip(只对文件,不保留原件) 打包: gzip file.txt 解压: gunzip file.txt.gzzip: -r 对目录 打包: zip file.zip file.txt 解压: unzip file.zip请写出数据类型(int,char,varchar,datetime,text)的意思;请问varchar和char有什么区别int整数 char定长字符 varchar变长字符 datetime日期时间型 text文本型varchar与char的区别: char是固定长度的字符类型,分配多少空间,就占用多少空间. varchar是可变长度的字符类型,内容有多大就占用多大空间,能有效节省空间. 由于varchar类型是可变的,所以在数据长度改变时,服务器要进行额外操作,所以效率比char低MyISAM和InnoDB的基本区别?索引结构如何实现MyISAM类型不支持事务,表锁,易产生碎片,要经常优化,读写速度较快, 而InnoDB类型支持事务行锁,有崩溃恢复能力.读写速度比MyISAM慢创建索引: alert table tablename add index (`字段名`)不使用COOKIE向客户端发送一个COOKIE理解: session_start()开启时, 生成一个常量SID, 当COOKIE开启时,这个常量为空, 当COOKIE关闭时, 这个常量中存储了PHPSESSID里面的值.通过在URL后加一个SID参数来传递SESSIONID的值,从而使客户端页面可以使用SESSION里面的值. 当客户端开启COOKIE和服务器端开启SESSION时.浏览器第一次请求,服务器会向浏览器端发送一个COOKIE里面存储SESSIONID. 当浏览器二次请求时,会把已存在的COOKIE一起提交到服务端isset()和empty的区别isset判断变量是否存在,可以传入多个变量,若其中一个变量不存在则返回假,empty判断变量是否为空为假,只可传入一个变量,如果为空为假则返回 TRUE如何在页面之间传递变量(至少两种方式)?GET POST PUT DELETE COOKIE SESSION写出匹配URL的正则表达式/^(https?|http?)://(www).([^./]+).(com|cn|org)(/[\\w-./?%&amp;=]*)$/i请说明PHP中传值与引用的区别.什么时候传值什么时候传引用按值传递: 函数范围内对值的任何改变在函数外部都会被忽略按引用传递: 函数范围内对值的任何改变在函数外部也能反映出这些修改优缺点: 按值传递时, php必须复制值. 特别是对于大型的字符串和对象来说, 这将会是一个代价很大的操作. 按引用传递则不需要复制值, 对于提升性能有很大的好处在PHP中error_reporting这个函数有什么作用设置PHP的报错级别并返回当前级别请用正则表达式写一个函数验证电子邮箱格式是否正确12345678/** * 邮箱检测 * @param string $email * @return boolean */function isEmail($email) &#123; return (boolean)preg_match(&#x27;/^[0-9a-zA-Z-]+@[0-9a-zA-Z-]+(\\.[0-9a-zA-Z-]+)&#123;1,3&#125;$/&#x27;, $email);&#125; 以空格做为间隔,拆分字符串’Apple Orange Banana Strawberry’,组成数组$fruit,数组中元素都用小写字母,并按照字母先后顺序排序123456789101112131415/** * 字符串拆分排序 * @param string $str * @return array */function strSplitSort( $str )&#123; if ( $str==&#x27;&#x27; ) &#123; return []; &#125; $str = strtolower($str); $arr = explode(&#x27; &#x27;, $str); sort($arr); return $arr;&#125; 对于用户输入一串字符$string, 要求$string中只能包含大于0的数字和英文逗号,请用正则表达式验证,对于不符合要求的$string返回错误信息12345678910111213/** * 验证字符串只能包含大于0的数字和英文逗号 * @param string $str * @return boolean */function regStr( $str, &amp;$error )&#123; if ( preg_match(&#x27;/^([1-9,])+$&#x27;, $str) ) &#123; return true; &#125; $error = &#x27;字符中只能包含大于0的数字和英文逗号&#x27;; return false;&#125; 请写一段程序,在服务器创建一个文件fruit.dat,将试题3中得到的数组写入到该文件中,然后写一段程序从文件中读取并还原数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Class file&#123; /** * @var array */ private $sort=[]; /** * @var string */ private $filepath; public function __construct($array, $path) &#123; $this-&gt;sort = $array; $this-&gt;filepath = $path; &#125; /** * 打开文件 * @param string $filename 文件名 * @param string $mode 打开方式 */ private function getresource($filename, $mode) &#123; return fopen($this-&gt;filepath.$filename, $mode); &#125; /** * 关闭文件 * @param $fopen */ private function closeresource($fopen) &#123; fclose($fopen); &#125; /** * 写入文件 * @param string $filename 文件名 */ public function savefile($filename) &#123; $fopen = $this-&gt;getresource($filename, &#x27;a+&#x27;); if ( ! $fopen ) &#123; echo &quot;文件打开失败&quot;;exit; &#125; foreach ( $this-&gt;sort as $key =&gt; $val ) &#123; fwrite($fopen, $value.&quot;\\n&quot;); &#125; $this-&gt;closeresource($fopen); &#125; /** * 读取文件 * @param string $filename * @return array */ public function readfile($filename) &#123; $fopen = $this-&gt;getresource($filename, &#x27;r&#x27;); if ( !$fopen ) &#123; echo &quot;文件打开失败&quot;;exit; &#125; $arr = []; while(!feof($fopen)) &#123; $get = fgets($fopen); if ( !empty($get) ) &#123; $arr[] = str_replace(&quot;\\n&quot;,&quot;&quot;,$get); &#125; &#125; $this-&gt;closeresource($fopen); return $arr; &#125; &#125; GET和POST的区别 GET在浏览器回退是无害的,而POST会再次提交请求 GET产生的URL地址可以被标记书签, 而POST不可以 GET请求会被浏览器主动缓存,而POST不会,除非手动设置 GET请求只能进行url编码,而POST支持多种编码方式 GET请求参数会被完整保留在浏览器历史记录里,而POST中的参数不会被保留 GET请求在URL中传送的参数是有长度限制的,而POST没有 对参数的数据类型,GET只接受ASCII字符,而POST没有限制 GET比POST更不安全,因为参数直接暴露在URL上,所以不能用来传递敏感信息 GET参数通过URL传递, POST放在Request body中 GET产生一个TCP数据包, POST产生两个TCP数据包require和include区别require是无条件包含也就是如果一个流程里加入require,无论条件成立与否都会先执行requireinclude有返回值,而require没有, require的速度比include快, 包含文件不存在或者语法错误的时候,require是致命的错误终止执行,include不是PHP的垃圾回收机制PHP可以自动进行内存管理,清除不需要的对象PHP使用了引用计数 GC机制每个对象都内含一个引用计数器 refcount, 每个reference连接到对象,计数器加1. 当reference离开生存空间或被设为NULL,计数器减一.当某个对象的引用计数器为零时, PHP将释放其所占的内存空间什么是CGI?什么是FastCGI?php-fpm,FastCGI,nginx之间的关系CGI,通用接口网关,用于WEB服务器和应用程序间的交互,定义输入输出规范,用户的请求通过WEB服务器转发给FastCGI进程,FastCGI进程在调用应用程序进行处理, 如PHP解析器,应用程序的处理结果返回给FastCGI,FastCGI返回给nginx进行输出. 假设这里WEB服务器是nginx,应用程序是PHP,而php-fpm是管理FastCGI的,这也就是php-fpm,FastCGI,和nginx之间的关系FastCGI用来提高cgi程序性能,启动一个master,在启动多个worker,不需要每次解析php.ini.而php-fpm实现了FastCGI协议,是FastCGI的进程管理器,支持平滑重启,可以启动的时候预先生成多个进程 参考博文[1] 2020最新PHP面试题（附带答案）","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"}],"author":"Zhu Xv"},{"title":"PHP练习题-字符串篇","slug":"PHP练习题-字符串篇","date":"2020-09-24T08:47:53.000Z","updated":"2020-11-20T03:10:38.379Z","comments":true,"path":"2020/09/24/PHP练习题-字符串篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/24/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/","excerpt":"字符串篇","text":"字符串篇 1.定义一个生成随机字符串的函数1234567891011121314/** * 生成随机字符串 * @param int $length 长度 * @return string */function generate_random_string(int $length=10)&#123; $chars = &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;; $randomString = &#x27;&#x27;; for ( $i=0; $i&lt;$length; $i++ ) &#123; $randomString .= $chars[rand(0, strlen($chars)-1)]; &#125; return $randomString;&#125; 2.不使用函数,写一个字符串反转的函数1234567891011121314/** * 字符串反转函数 * @param string $str * @return string */function str_inver( string $str )&#123; $newStr = &#x27;&#x27;; $m = strlen($str) - 1; for( $i=$m; $i&gt;=0; $i-- ) &#123; $newStr .= $str[$m]; &#125; return $newStr;&#125; 3.写一个函数,将字符串每几位用指定符号隔开1234567891011121314151617181920/** * 将字符串隔几位用指定符号隔开 * @param string $str * @param string $symbol * @param int $num 每隔几位隔开 * @return string */function separate( string $str, string $symbol=&#x27;,&#x27;, int $num=3)&#123; $newStr = &#x27;&#x27;; $length = strlen($str); // 获取字符串长度 $k = $length%$num; for( $i=0; $i&lt;$length; $i++ ) &#123; if ( $i%$num == $k &amp;&amp; $i != 0 ) &#123; $newStr .= $symbol; &#125; $newStr .= $str[$i]; &#125; return $newStr;&#125; 4.获取文件扩展名123456789101112/** * 获取文件扩展名 * @param string $url 文件路径 * @return string */function ext_name(string $url)&#123; if ( strstr($url, &#x27;?&#x27;) ) &#123; $url = explode(&#x27;?&#x27;, $url)[0]; &#125; return end(explode(&#x27;.&#x27;, $url));&#125; 5.写一个函数,计算出两个文件的相对路径123456789101112131415161718192021222324/** * 计算出两个文件的相对路径 * @param string $path1 * @param string $path2 * @return string */function relative_path( string $path1, string $path2 )&#123; // 获取两文件的目录 $path1 = trim(dirname($path1), &#x27;/&#x27;); $path2 = trim(dirname($path2), &#x27;/&#x27;); $path1Arr = explode(&#x27;/&#x27;, $path1); $path2Arr = explode(&#x27;/&#x27;, $path2); $num = max(count($path1Arr), count($path2Arr)); for( $i=0; $i&lt;$num; $i++ ) &#123; if ( $path1Arr[$i] !== $path2Arr[$i] ) &#123; break; &#125; unset($path1Arr[$i], $path2Arr[$i]); &#125; return str_repeat(&#x27;../&#x27;, count($path2Arr)).implode(&#x27;/&#x27;, $path1Arr);&#125; 6.给出一个字符串,返回里面连续的字母的个数,比如:abbcddde,返回1a2b1c3d1e1234567891011121314151617181920/** * @param string $string * @return string */function count_str($string)&#123; $re = &#x27;&#x27;; $arr = str_split($string); //把字符串变成数组 $countStr = count($arr); $key = 0; // key用来记录下标 for ( $i=0; $i&lt;$countStr; $i++ ) &#123; $v = $arr[$i]; if ( $arr[$i] == $arr[$i+1] ) &#123; continue; &#125; $re .= ($i-$key+1).$v; //不相等时计算出前面的数字 $key = $i + 1; // 同时 key 下标重新复制 &#125; return $re;&#125; 参考博文[1] 面试10家公司，收获9个offer，2020年PHP 面试问题","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"},{"name":"字符串","slug":"字符串","permalink":"https://zhuxv.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Zhu Xv"},{"title":"PHP练习题-数组篇","slug":"PHP联系题-数组篇","date":"2020-09-24T02:55:38.000Z","updated":"2020-11-20T02:26:17.317Z","comments":true,"path":"2020/09/24/PHP联系题-数组篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/24/PHP%E8%81%94%E7%B3%BB%E9%A2%98-%E6%95%B0%E7%BB%84%E7%AF%87/","excerpt":"数组篇通过工作中的几次教训, 终于领悟到题还是要刷滴, 整理出一些常见题型","text":"数组篇通过工作中的几次教训, 终于领悟到题还是要刷滴, 整理出一些常见题型 1. 请使用PHP实现冒泡排序，将数组$a = array()按照从小到大的方式进行排序1234567891011121314151617181920/** * 冒泡排序 * @param array $arr 需要排序的数组 * @return array|false */function bubble_sorting( array $arr )&#123; $len = count($arr); // 最外层循环控制需要冒泡的轮数 for ( $i=1; $i &lt; $len; $i++ ) &#123; for ( $j=0; $j &lt; $len-$i; $j++ ) &#123; if ( $arr[$j] &gt; $arr[$j+1] ) &#123; $tmp = $arr[$j+1]; $arr[$j+1] = $arr[$j]; $arr[$j] = $tmp; &#125; &#125; &#125; return $arr;&#125; 2.创建一个长度为10的数组, 数组中的元素为递增的奇数, 首项为112345678910111213/** * 创建一个元素递增为奇数的数组 * @param int $first 第一个元素的值 * @param int $length 数组长度 */function element_odd_number_arr(int $first=1, int $length=10)&#123; $arr = []; for ( $i=0; $i &lt; $length; $i++ ) &#123; $arr[] = ($i+$first) * 2 - 1; &#125; return $arr;&#125; 3.求出数组中最大下标1234567891011121314151617181920/** * 得出数组中最大值的下标 * @param array $arr * @return mixed */function max_key(array $arr)&#123; $maxKey = false; foreach ( $arr as $key =&gt; $item ) &#123; if ( !isset($maxVal) ) &#123; $maxVal = $item; $maxKey = $key; continue; &#125; if ( $maxVal &lt; $item ) &#123; $maxKey = $key; &#125; &#125; return $maxKey;&#125; 4.创建一个指定长度的数组, 数组中的元素满足斐波拉契数列的规律斐波拉契数列又称黄金分割数, 如下的定义方法: F0=0, F1=1, Fn=F(n-1)+F(n-2)（n&gt;=2，n∈N*） 1234567891011121314151617/** * 创建一个元素满足斐波拉契数列规律的数组 * @param int $length 数组长度 * @return array */function golden_section_arr(int $length=10)&#123; $result = []; for ( $i = 0; $i &lt; $length; $i++ ) &#123; if ( $i &lt; 2 ) &#123; $result[$i] = $i; continue; &#125; $result[$i] = $result[$i-1] + $result[$i-2]; &#125; return $result;&#125; 5.计算数组中最大数和最小数的差12345678910/** * 计算数组中的最大数和最小数的差值 * @param array $arr * @return int */function diff_val(array $arr)&#123; sort($arr); return end($arr)-reset($arr);&#125; 6.截取数组元素后几位拼接到数组前,顺序不变1234567891011121314151617/** * 截取数组元素后几位拼接到数组前 * @param array $arr * @param int $length 要截取的位数 * @return array|false */function cut_splice_arr(array $arr, int $length=1)&#123; $count = count($arr); if ( $count &lt; $length ) &#123; return false; &#125; $front = array_slice($arr, 0, $count-$length, true); $after = array_slice($arr, $count-$length, $length, true); return array_merge($after, $front);&#125; 7.不使用函数,将两个数组组成一个数组12345678910111213/** * 将两个数组组成一个数组 * @param array $arr1 * @param array $arr2 * @return array */function recombinate_array(array $arr1, array $arr2)&#123; foreach ( $arr1 as $_item ) &#123; $arr2[] = $_item; &#125; return $arr2;&#125; 8.数组逆序(不能使用rsort函数, 不能生成新的数组)123456789101112131415161718192021222324252627/** * 数组逆序 * @param array $arr * @return array */function reverse_order_arr(array $arr)&#123; $i = &quot;&quot;; // 要替换位置的数的下标 $j = &quot;&quot;; // 临时变量 $k = &quot;&quot;; // 被替换位置的数的下标 $len = count($arr); $half_len = floor($len/2); // 向下取整,取整的值是循环的次数 for( $i=0; $i&lt;$half_len; $i++ ) &#123; $j = $arr[$i]; // 判断数组个数奇偶 if ( $len % 2 !== 0 ) &#123; $k = $half_len*2-$i; &#125; else &#123; $k = $half_len*2-$i-1; &#125; $arr[$i] = $arr[$k]; $arr[$k] = $j; &#125; return $arr;&#125; 9.快速排序1234567891011121314151617181920212223/** * 数组快速排序 * @param array $arr * @return array */ function quick_sort(array $arr)&#123; $count = count($arr); if ( $count &lt;= 1 ) return $arr; $key = $arr[0]; $left_arr = []; $right_arr = []; for ( $i=1; $i&lt;$count; $i++ ) &#123; if ( $arr[$i] &lt;= $key ) &#123; $left_arr[] = $arr[$i]; &#125; else &#123; $right_arr[] = $arr[$i]; &#125; &#125; $left_arr = quick_sort($left_arr); $right_arr = quick_sort($right_arr); return array_merge($left_arr, [$key], $right_arr);&#125; 10.二分法查找数组中的某个元素1234567891011121314151617181920212223242526272829/** * 二分法查找数组中某元素 * @param array $array * @param int low 最低的数 * @param int $high 最高的数 * @param int $k 需要查找的元素 * @return int|false */function bin_sch($array, $k, $low=0, $high=0)&#123; $count = count($array); if ( $count != 0 &amp;&amp; $high == 0 ) &#123; // 第一次使用 // 数组元素个数 $high = $count; &#125; if ( $low &lt;= $high ) &#123; // 如果还存在剩余的数组元素 $mid = intval(($low+$high)/2); // 取$low与high的中间值 if ( $array[$mid] == $k ) &#123; return $mid; &#125; elseif ( $k &lt; $array[$mid] ) &#123; // 如果上面没有找到, 则继续查找 return search($array, $k, $low, $mid-1); &#125; else &#123; return search($array, $k, $mid+1, $high); &#125; &#125; return false;&#125; 11.顺序查找数组里的某个元素123456789101112131415/** * 顺序查找数组中某元素 * @param array $array * @param int $k 需要查找的元素 * @return int|false */function query_search($array, $k)&#123; foreach ( $array as $key =&gt; $val ) &#123; if ( $val == $key ) &#123; return $key; &#125; &#125; return false;&#125; 12.二维数组排序1234567891011/** * 二维数组排序 * @param array $array * @param string $key * @param $sort * @return array */function array_sort($array, $key, $sort=SORT_ASC)&#123; return array_multisort(array_column($array, $key), $sort, $array);&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"},{"name":"数组","slug":"数组","permalink":"https://zhuxv.github.io/tags/%E6%95%B0%E7%BB%84/"}],"author":"Zhu Xv"}],"categories":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"},{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://zhuxv.github.io/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"},{"name":"并发","slug":"并发","permalink":"https://zhuxv.github.io/categories/%E5%B9%B6%E5%8F%91/"},{"name":"算法","slug":"算法","permalink":"https://zhuxv.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"WEB安全","slug":"WEB安全","permalink":"https://zhuxv.github.io/categories/WEB%E5%AE%89%E5%85%A8/"},{"name":"架构","slug":"架构","permalink":"https://zhuxv.github.io/categories/%E6%9E%B6%E6%9E%84/"},{"name":"MVC","slug":"MVC","permalink":"https://zhuxv.github.io/categories/MVC/"},{"name":"REDIS","slug":"REDIS","permalink":"https://zhuxv.github.io/categories/REDIS/"},{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/categories/MySQL/"},{"name":"服务","slug":"服务","permalink":"https://zhuxv.github.io/categories/%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"PHP7","slug":"PHP7","permalink":"https://zhuxv.github.io/tags/PHP7/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://zhuxv.github.io/tags/Elasticsearch/"},{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://zhuxv.github.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://zhuxv.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"高并发","slug":"高并发","permalink":"https://zhuxv.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"},{"name":"算法","slug":"算法","permalink":"https://zhuxv.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"WEB","slug":"WEB","permalink":"https://zhuxv.github.io/tags/WEB/"},{"name":"安全","slug":"安全","permalink":"https://zhuxv.github.io/tags/%E5%AE%89%E5%85%A8/"},{"name":"CSRF","slug":"CSRF","permalink":"https://zhuxv.github.io/tags/CSRF/"},{"name":"DDOS","slug":"DDOS","permalink":"https://zhuxv.github.io/tags/DDOS/"},{"name":"XSS","slug":"XSS","permalink":"https://zhuxv.github.io/tags/XSS/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://zhuxv.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"架构","slug":"架构","permalink":"https://zhuxv.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"RESTful","slug":"RESTful","permalink":"https://zhuxv.github.io/tags/RESTful/"},{"name":"MVC","slug":"MVC","permalink":"https://zhuxv.github.io/tags/MVC/"},{"name":"REDIS","slug":"REDIS","permalink":"https://zhuxv.github.io/tags/REDIS/"},{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/tags/MySQL/"},{"name":"服务","slug":"服务","permalink":"https://zhuxv.github.io/tags/%E6%9C%8D%E5%8A%A1/"},{"name":"字符串","slug":"字符串","permalink":"https://zhuxv.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数组","slug":"数组","permalink":"https://zhuxv.github.io/tags/%E6%95%B0%E7%BB%84/"}]}