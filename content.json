{"meta":{"title":"小朱的技术博客","subtitle":"","description":"","author":"Zhu Xv","url":"https://zhuxv.github.io","root":"/"},"pages":[{"title":"","date":"2020-09-27T08:48:48.507Z","updated":"2020-09-27T08:48:48.399Z","comments":true,"path":"about/index.html","permalink":"https://zhuxv.github.io/about/index.html","excerpt":"","text":"关于我从事 WEB 开发，主要开发语言 PHP，熟悉使用 Laravel、ThinkPHP 等主流框架； 对服务端、前端、服务器 相关技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：上海 关于学习正在往终身学习者前进…近期学习方向：Linux(服务器, 运行环境) 关于座右铭 深林几处啼鹃, 梦如烟 关于爱好热爱运动，游戏，尤其喜爱阅读、电影、旅行。 联系我 Home: zhuxv.com Blog: zhuxv.github.io Email: &#49;&#x30;&#55;&#49;&#x37;&#x38;&#x36;&#x32;&#48;&#52;&#x40;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d; GitHub: ZhuXv WeiBo: Twitter:"}],"posts":[{"title":"PHP练习题-REDIS篇","slug":"PHP练习题-REDIS篇","date":"2020-09-27T08:16:51.000Z","updated":"2020-09-27T10:14:55.127Z","comments":true,"path":"2020/09/27/PHP练习题-REDIS篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/27/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-REDIS%E7%AF%87/","excerpt":"REDIS篇REDIS 练习笔记","text":"REDIS篇REDIS 练习笔记 1.redis和memcached相比有哪些优势memcached 所有的值均是简单的字符串, redis 做为其代替者, 支持更丰富的数据类型 redis 的速度比 memcached 快很多 redis 可以持久化其数据 2.redis是单线程redis 利用队列技术将并发访问变成串行访问, 消除了传统数据库串行控制的开销 3.redis的五种数据类型string, list, set, sorted set, hash 4.redis的并发竞争问题如何解决单线程单进程模式, 采用队列模式将并发访问改为串行访问. redis 本身没有锁的概念, redis 对于多个客户端连接不存在竞争, 利用 setnx 实现锁 5.redis启动命令./redis-server 6.redis 支持的语言Java, C, C#, C++, PHP, Node.js GO 等 7.redis 持久化解决方案RDB RDB 持久化是把当前进程数据生成快照保存到硬盘的过程, 触发 RDB 持久化过程分为手动触发和自动触发 RDB 完成后会自动生成一个文件, 保存在 dir 配置的指定目录下, 文件名是 dbfilename 指定 REDIS 默认会采用 LZF 算法对生成的 RDB 文件做压缩处理, 压缩后的文件远远小于内存大小, 默认开启 手动触发: 手动触发的命令有 save 和 bgsave save: 该命令会阻塞 Redis 服务器, 直到 RDB 的过程完成, 已经被废弃, 因此线上不建议使用 bgsave: 每次进行 RDB 过程都会 fork 一个子进程, 由子进程完成 RDB 操作, 因此阻塞只会发生在 fork 阶段, 一般时间很短 自动触发: (1) 根据我们的 save m n 配置规则自动触发 (2) 如果从节点执行全量复制操作, 主节点自动执行 bgsave 生成 RDB 文件并发送给从节点 (3) 执行 debug reload 命令重新加载 Redis 时, 也会触发 save 操作 (4) 默认情况下执行 shutdown 命令时, 如果没有开启 AOF 持久化功能则自动执行 bgsave 优点: RDB 是一个紧凑的压缩的二进制文件, 代表 Redis 在某个时间点上的数据快照. 非常适用与备份, 全量复制等场景. 比如每六个小时执行 bgsave 备份, 并把 RDB 文件拷贝到远程机器或者文件系统中, 用于灾难恢复 Redis 加载 RDB 恢复数据远远快于 AOF 的方式 缺点: RDB 方式数据没办法做到 实时持久化/秒级持久化. 因为 bgsave 每次运行都要执行 fork 操作创建子进程, 属于重量级操作, 频繁执行成本太高 RDB 文件使用特定的二进制格式保存, Redis 版本演进过程中有多个格式 RDB 版本, 存在老版本 Redis 服务无法兼容新版本 RDB 格式问题 AOF(append only file) 以独立日志的方式记录每次写命令, 重启时在重新执行 AOF 文件中的命令达到恢复数据的目的. AOF 的主要作用是解决了数据持久化的实时性, 目前已是 Redis 持久化的主流方式 如何开启AOF 开启 AOF 功能需要设置配置: appendonly yes, 默认不开启. AOF 文件名通过 appendfilename 配置设置, 默认文件名是 appendonly.aof. 保存路径同 RDB 持久化方式一致, 通过 dir 配置指定 优点: 使用 AOF 持久化会让 Redis 变的非常耐久: 你可以设置不同的 fsync 策略, 比如无 fsync, 每秒钟一次 fsync, 或者每次执行写入命令时 fsync. AOF 的默认策略为每秒钟 fsync 一次, 在这种配置下, Redis 仍然能够保持良好的性能, 并且就算发生故障停机, 也最多只会丢失一秒钟数据 缺点: 对于相同的数据集来说, AOF 文件的体积通常要大于 RDB 文件的体积. 根据所使用的 fsync 策略, AOF 的速度可能会慢与 RDB. 在一般情况下, 每秒 fsync 的性能依然非常高, 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快, 即使在高负荷之下也是如此. 不过在处理巨大的写入载入时, RDB 可以提供更有保证的最大延迟时间 数据恢复速度相对于 RDB 比较慢 AOF和RDB的区别 RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘, 实际操作过程是 fork 一个子进程, 先将数据集写入临时文件, 写入成功后, 在替换之前的文件, 用二进制压缩存储 AOF持久化以日志的形式记录服务器所处理的每一个写, 删除操作, 查询操作不会记录, 以文本的方式记录, 可以打开文件看到详细的操作记录 性能和解决方案 通过上面的分析, 我们都知道 RDB 的快照, AOF 的重写都需要 fork, 这是一个重量级操作, 会对 Redis 造成阻塞. 因此为了不影响 Redis 主进程, 我们需要尽可能降低阻塞. 如何减少 fork 操作的阻塞 (1) 优先使用物理机或者高效支持 fork 操作的虚拟化技术 (2) 控制 Redis 实例最大可用内存, fork 耗时跟内存量成正比, 线上建议每个 Redis 实例内存控制在 10G 以内 (3) 合理配置 LINUX 内存分配策略, 避免物理内存不足导致 fork 失败 (4) 降低 fork 操作的频率, 如适度放宽 AOF 自动触发时机, 避免不必要的全量复制等 参考博文[1] 吐血整理60个Redis面试题,全网最全了[2] 天天用Redis，持久化方案你知道哪些？","categories":[{"name":"REDIS","slug":"REDIS","permalink":"https://zhuxv.github.io/categories/REDIS/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"REDIS","slug":"REDIS","permalink":"https://zhuxv.github.io/tags/REDIS/"}],"author":"Zhu Xv"},{"title":"PHP练习题-MySQL篇","slug":"PHP练习题-MySQL篇","date":"2020-09-25T06:17:43.000Z","updated":"2020-09-27T08:09:45.863Z","comments":true,"path":"2020/09/25/PHP练习题-MySQL篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/25/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-MySQL%E7%AF%87/","excerpt":"MySQL篇","text":"MySQL篇 1.MySQL的复制原理及其流程:1.主[binlog线程] 记录下所有改变了数据库数据的语句, 放进 master 上的 binlog 中 2.从[io线程] 在使用 start slave 之后, 负责从 master 上拉取 binlog 内容, 放进自己的 relay log 中 3.从[sql执行线程] 执行 relay log 中的语句 2.MySQL中MyISAM与InnoDB的区别:1 五点不同 (1) InnoDB支持事务, MyISAN不支持事务 (2) InnoDB支持行级锁, MyISAN支持表级锁 (3) InnoDB支持多版本并发控制(MVCC), MyISAN不支持MVCC (4) InnoDB支持外键, MyISAN不支持外键 (5) InnoDB不支持全文索引, 而MyISAN不支持索引 2 InnoDB引擎的4大特征 (1) [插入缓冲(insert buffer)](https://blog.csdn.net/dbanote/article/details/9077113) (2) [二次写(double write)](https://blog.csdn.net/dbanote/article/details/9078091) (3) [自适应哈希索引(ahi)](https://blog.csdn.net/dbanote/article/details/9078129) (4) [预读(read ahead)](https://blog.csdn.net/qq9808/article/details/105846413) 3 MyISAN和InnoDB统计哪个更快 MyISAN更快, 因为MyISAN内部维护了一个计数器 4 MyISAN和InnoDB的选择 (1) 需要支持事务,行级锁,外键选择InnoDB (2) 如果表中没有大量的新增删除修改,对原子性要求低,那么MyISAN是最好的选择(更建议使用nosql) (3) 系统崩溃后MyISAM恢复起来更困难 (4) 高并发建议使用InnoDB 3.MySQL中varchar与char的区别以及varchar(50)中的50代表的含义:1.char是一种固定长度的类型, varchar则是一种可变长度类型 2.varchar(50)中50的含义最多存放50个字符, varchar(50)和varchar(200)存储相同字符串所占空间一样,但是后者在排序时会消耗更多内存, 因为 order by col 采用 fixed_length 长度计算 col 长度(memory引擎也一样) 4.InnoDB事务与日志的实现方式1.有多少种日志 (1) 错误日志: 记录出错信息, 也记录一些警告和正确信息 (2) 查询日志: 记录所有对数据库请求的信息, 不论这些请求是否得到了正确的执行 (3) 慢查询日志: 设置一个阈值, 将运行时间超过该值的查询语句记录到日志中 (4) 二进制日志: 记录对数据库执行更改的所有操作 (5) 中继日志 (6) 事务日志 2.事务的4种隔离级别 (1) 读未提交(RU) (2) 读已提交(RC) (3) 可重复度(RR) (4) 串行 3.事务是如何通过日志来实现的 事务日志是通过 redio 和 innodb 的存储引擎日志缓冲 (Innodb log buffer) 来实现的, 当开始一个事务的时候, 会记录该事物的 isn(log sequence number)号; 当事务执行时, 会往 InnoDB 存储引擎日志的日志缓存里面插入事务; 当事务提交时, 必须将存储引擎的日志缓冲写入磁盘 (通过 innodb_flush_log_at_trx_commit 来控制), 也就是写数据前, 需要先写日志. 这种方式称为 &quot;预写日志方式&quot; 5.MySQL binlog的几种日志录入格式以及区别1.Statement: 每一条会修改数据的 sql 都会记录在 binlog 中 优点: 不需要记录每一行的变化, 减少了 binlog 的日志量, 节约了 IO, 提高了性能 缺点: 由于记录的只是执行语句, 为了这些语句能在 slave 上正确运行, 因此还必须记录每条语句在执行的时候的一些相关信息, 以保证所有语句能在 slave 得到和在 master 端执行时候的相同结果. 另外 mysql 的复制, 像一些特定函数功能, slave 可与 master 上要保持一致会有很多先关问题,比如使用一些函数将会出现一些问题或无法复制的现象 2. Row: 不记录 sql 语句上下文相关信息, 仅保存哪条记录被修改 优点: binlog 中不记录执行 sql 相关上下文信息, 仅需要记录哪一条记录被修改成什么了.所以 rowlevel 的日志内容会非常清楚的记录下每一行的数据修改的细节. 而且不会出现某些特定情况下的存储过程或 function 以及 trigger 的调用和触发无法被正确复制的问题 缺点: 所有的执行语句当记录到日志中的时候, 都将以每行记录的修改来记录, 这样会产生大量的日志内容 3. MixedLevel: 是以上两种级别的混合使用, 一般的语句修改使用 statement 格式保存 binlog, 如一些函数, statement 无法完成主从复制的操作, 则采用 row 格式保存 binlog, MySQL 会根据执行的每一条具体的 sql 语句来区分对待记录的日志形式, 也就是在 Statement 和 Row 之间选择一种, 新版本的 MySQL 中对 row level 模式也被做了优化, 并不是所有的修改都会以 row level 来记录, 像遇到表结构变更的时候就会以 statement 模式来记录. 至于 update 或者 delete 等修改数据的语句, 还是会记录所有行的变更 6.MySQL数据库CPU飙升到500%如何处理1. 列出所有进程 show processlist 观察所有进程, 多秒没有状态变化的 kill 掉 2. 查看超时日志或者错误日志, 一般会是查询以及大批量的插入会导致 CPU 与 I/O 上涨 7.sql优化1. 避免全文扫描, 首先考虑在 where 及 order by 上建立索引 2. 避免在 where 子句中对字段进行 null 判断, 避免使用 != &lt;&gt; 操作符, 避免使用 or 查询 3. in 和 not in 也要慎重使用, 很多时候使用 exists 代替 in 是一个很好的选择 4. 使用 like 时禁止左边模糊查询 5. 在 where 子句中避免对字段进行表达式操作 示例: where num/2=100 应改为 where num=100*2 6. 不要在 where 子句中的等于号 &quot;=&quot; 左边进行函数,算术表达式及其他表达式运算 7. 在使用索引字段作为条件时, 如果该索引是复合索引, 那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引, 否则该索引将不会被使用, 并且应尽可能的让字段顺序与索引顺序保持一致 8. 如果有大量重复数据时,这个字段应该避免建立索引 9. 索引可以提高查询效率, 但同样也可以降低插入和编辑效率, 所以要适量建立索引,一张表最好不超过6个索引 10. 尽量使用数字型字段, 字符型字段会降低查询和连接的性能, 并增加存储开销 11. 尽量使用 varchar 代替 char, 可以节约存储空间, 在一个相对较小的字段内搜索效率显然会更高一些 12. 查询时应该用具体字段代替 * 查询 13. 避免频繁创建临时表和删除临时表, 以减少系统表资源的消耗 14. 临时表并不是不可以使用, 当需要重复引用大型表或常用表中的某个数据集时 15. 在新建临时表时, 如果一次性插入数据量过大, 那么可以使用 select into 代替 create table, 避免造成大量log. 如果数据量不大, 为了缓和表的资源, 应先使用 create table, 然后 insert 16. 如果使用到了临时表, 在存储过程的最后务必将所有的临时表显式删除, 先 truncate table, 然后 drop table, 这样可以避免系统表较长时间锁定 17. 尽量避免使用游标查询, 因为游标查询效率太差, 如果有游标操作的数据超过 1万 行, 那么应该考虑改写 18. 使用游标或者临时表方法之前, 应先寻找基于集的解决方案来解决问题, 基于集的方法通常更有效 19. 尽量避免大事务操作, 提高系统并发能力 20. 尽量避免向客户返回大量数据, 若数据量过大, 应该考虑相应需求是否合理 8.InnoDB的读写参数优化1. innodb_buffer_poor_size: 用于缓冲数据和索引, 对于mysql的性能升级是线性的, 通常对于独立的 MySQL 服务器, innodb_buffer_poor_size最大可设置为内存大小的 70%-80% 计算方法: val = Innodb_buffer_pool_pages_data / Innodb_buffer_pool_pages_total * 100% val &gt; 95% 则考虑增大 innodb_buffer_pool_size， 建议使用物理内存的75% val &lt; 95% 则考虑减小 innodb_buffer_pool_size， 建议设置为：Innodb_buffer_pool_pages_data * Innodb_page_size * 1.05 / (1024*1024*1024) 2. 开启慢查询日志 slow.log, 增加参数: log_queries_not_using_indexes, 所有没有走索引的 sql 语句都会记录到 slow.log 中 3. 提高 query_cache 的命中率 命中率计算方法: Qcache_hits/(Qcache_hits + Qcache_inserts) * 100% 提高 qcache 命中率的方法: 数据动静分离 操作频繁的表和操作不频繁的表分开存放, 数据频繁更改会导致 query_cache 失效 单条 sql 语句的 query_cache 大小是有限制的, 当一条 sql 语句返回的数据大小超过 query_cache_limit 的值时不会缓存,可以适量增加 query_cache_limit 的值. query_cache_size 表示所有 query_cache 的总大小. 当整个数据库的 query_cache 大小超过该值, sql 语句也无法缓存 4. 高并发的情况下建议关闭 query_cache, 不然会有很多的 qcache 锁等待 9.你们的数据库是否支持emoji表情, 如果不支持, 应该怎么做如果是 UTF-8 字符集的话升级至 utf8-mb4 即可 10.表中有大字段x(例如: text类型),且字段x不会经常更新,已读为主,你会选择拆成子表还是放在一起,理由?拆开带来的问题: 连接消耗+存储拆分空间 不拆带来的问题: 查询性能 如果能容忍拆分带来的空间问题: 拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区)顺序IO,减少连接消耗, 最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗 如果能容忍不拆分带来的查询性能损失的话: 上面的方案在某个极致条件下肯定会出现问题, 那么不拆是最好的选择 11.MySQL中InnoDB引擎的行锁是通过加在什么上实现的,为什么InnoDB 是基于索引来完成行锁 例: select * from `table` where id=1 for update; for update 可以根据条件来完成行锁锁定, 并且 id 是有索引键的列, 如果 id 不是索引键, 那么 InnoDB 将完成表锁, 只有在 InnoDB 引擎和事务中才能生效 12.开放性问题:一个6亿的表a, 一个3亿的表b, 通过外键 tid 关联, 你如何最快的查询出满足条件的第 50000-50200 的 200 条数据的记录 1. 如果a表 tid 是自增长的, 并且是连续的, b表的 ID 为索引 select * from a,b where a.tid = b.id and a.tid &gt; 50000 limit 200; 2. 如果a表的 tid 不是连续增长的, 那么就需要使用覆盖索引. tid 要么是主键, 要么是辅助索引, b表 ID 也要有索引 select * from b, (select tid from a limit 50000,200) a where b.id = a.tid 参考博文[1] 【MySQL】20个经典面试题[2] sql优化的几种方式[3] 关于mysql innodb引擎性能优化的一点心得","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/tags/MySQL/"},{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"author":"Zhu Xv"},{"title":"apache与nginx的区别","slug":"apache与nginx的区别","date":"2020-09-25T02:06:57.000Z","updated":"2020-09-25T09:15:40.159Z","comments":true,"path":"2020/09/25/apache与nginx的区别/","link":"","permalink":"https://zhuxv.github.io/2020/09/25/apache%E4%B8%8Enginx%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"apache与nginx的区别记录一下apache与nginx的区别, 以便在工作中可以正确选择","text":"apache与nginx的区别记录一下apache与nginx的区别, 以便在工作中可以正确选择 Nginx:1.轻量级, 采用C编写, 同样的web服务, 会占用更少的内存及资源 2.抗并发, 处理请求是异步非阻塞的, 负载能力比 apache 高很多, 而 apache 则是阻塞型的. 在高并发下 nginx 能保持低资源低消耗高性能, 而 apache 在 PHP 处理慢或者前端压力很大的情况下, 很容易出现进程数飙升, 从而拒绝服务现象 3.nginx 处理静态文件好, 静态处理性能是 apache 的三倍以上 4.nginx 的设计高度模块化, 编写模块相对简单 5.nginx 配置简洁, 正则配置让很多事情变得简单, 而且改完配置能使用 nginx -t 测试配置有没有问题, apache 配置复杂, 重启之后发现配置错误,会很崩溃 6.nginx 作为负载均衡服务器, 支持 7 层负载均衡 7.nginx 本身就是一个反向代理服务器, 而且可以作为非常优秀的邮件代理服务器 8.启动特别容易, 并且可以做到 24 小时不断运行, 即使运行数月也不需要重新启动, 还能够不间断服务的情况下进行版本升级 9.社区活跃, 各种高性能模块出品迅速 Apache:1.apache 的 rewrite 比 nginx 强大, 在 rewrite 频繁的情况下, 用 apache 2.apache 发展到现在, 模块超多, 基本想到的都可以找到 3.apache 更为成熟, 少 BUG, nginx BUG 相对比较多 4.apache 非常稳定 5.apache 对 PHP 支持比较简单, nginx 需配合其他后端用 6.apache 在处理动态请求的时候有优势, nginx 在这方面是鸡肋, 一般动态请求要 apache 去做, nginx 适合反向和静态 7.apache 仍然是目前的主流, 拥有丰富的特性, 成熟的技术和开发社区 总结两者最核心的区别在于 apache 是同步多进程模型, 一个连接对应一个进程, 而 nginx 是异步的, 多连接可以对应一个进程一般来说, 需要性能的 web 服务, 用 nginx, 如果不需要性能只要求稳定的服务, 更考虑的是 apache, 后者各种功能模块实现的比前者好, 可配置项多更为通用的方案是, 前端 nginx 抗并发, 后端 apache 集群, 配合起来会更好 参考博文[1] Apache和Nginx的区别","categories":[{"name":"系统","slug":"系统","permalink":"https://zhuxv.github.io/categories/%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"系统","slug":"系统","permalink":"https://zhuxv.github.io/tags/%E7%B3%BB%E7%BB%9F/"}],"author":"Zhu Xv"},{"title":"PHP练习题-基础篇","slug":"PHP练习题-基础篇","date":"2020-09-25T02:00:23.000Z","updated":"2020-09-25T09:13:31.059Z","comments":true,"path":"2020/09/25/PHP练习题-基础篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/25/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"基础篇","text":"基础篇 1.PHP语言的一大优势是跨平台,什么是跨平台PHP运行环境可以在不同的操作系统(例如: windows, linux等)上配置, 不受操作系统的限制, 所以叫跨平台","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"}],"author":"Zhu Xv"},{"title":"PHP练习题-字符串篇","slug":"PHP练习题-字符串篇","date":"2020-09-24T08:47:53.000Z","updated":"2020-09-25T09:13:46.521Z","comments":true,"path":"2020/09/24/PHP练习题-字符串篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/24/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/","excerpt":"字符串篇","text":"字符串篇 1.定义一个生成随机字符串的函数1234567891011121314/** * 生成随机字符串 * @param int $length 长度 * @return string */function generate_random_string(int $length=10)&#123; $chars = &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;; $randomString = &#x27;&#x27;; for ( $i=0; $i&lt;$length; $i++ ) &#123; $randomString .= $chars[rand(0, strlen($chars)-1)]; &#125; return $randomString;&#125; 2.不使用函数,写一个字符串反转的函数1234567891011121314/** * 字符串反转函数 * @param string $str * @return string */function str_inver( string $str )&#123; $newStr = &#x27;&#x27;; $m = strlen($str) - 1; for( $i=$m; $i&gt;=0; $i-- ) &#123; $newStr .= $str[$m]; &#125; return $newStr;&#125; 3.写一个函数,将字符串每几位用指定符号隔开1234567891011121314151617181920/** * 将字符串隔几位用指定符号隔开 * @param string $str * @param string $symbol * @param int $num 每隔几位隔开 * @return string */function separate( string $str, string $symbol=&#x27;,&#x27;, int $num=3)&#123; $newStr = &#x27;&#x27;; $length = strlen($str); // 获取字符串长度 $k = $length%$num; for( $i=0; $i&lt;$length; $i++ ) &#123; if ( $i%$num == $k &amp;&amp; $i != 0 ) &#123; $newStr .= $symbol; &#125; $newStr .= $str[$i]; &#125; return $newStr;&#125; 4.获取文件扩展名123456789101112/** * 获取文件扩展名 * @param string $url 文件路径 * @return string */function ext_name(string $url)&#123; if ( strstr($url, &#x27;?&#x27;) ) &#123; $url = explode(&#x27;?&#x27;, $url)[0]; &#125; return end(explode(&#x27;.&#x27;, $url));&#125; 5.写一个函数,计算出两个文件的相对路径123456789101112131415161718192021222324/** * 计算出两个文件的相对路径 * @param string $path1 * @param string $path2 * @return string */function relative_path( string $path1, string $path2 )&#123; // 获取两文件的目录 $path1 = trim(dirname($path1), &#x27;/&#x27;); $path2 = trim(dirname($path2), &#x27;/&#x27;); $path1Arr = explode(&#x27;/&#x27;, $path1); $path2Arr = explode(&#x27;/&#x27;, $path2); $num = max(count($path1Arr), count($path2Arr)); for( $i=0; $i&lt;$num; $i++ ) &#123; if ( $path1Arr[$i] !== $path2Arr[$i] ) &#123; break; &#125; unset($path1Arr[$i], $path2Arr[$i]); &#125; return str_repeat(&#x27;../&#x27;, count($path2Arr)).implode(&#x27;/&#x27;, $path1Arr);&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"},{"name":"字符串","slug":"字符串","permalink":"https://zhuxv.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Zhu Xv"},{"title":"PHP练习题-数组篇","slug":"PHP联系题-数组篇","date":"2020-09-24T02:55:38.000Z","updated":"2020-09-25T09:16:02.638Z","comments":true,"path":"2020/09/24/PHP联系题-数组篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/24/PHP%E8%81%94%E7%B3%BB%E9%A2%98-%E6%95%B0%E7%BB%84%E7%AF%87/","excerpt":"数组篇通过工作中的几次教训, 终于领悟到题还是要刷滴, 整理出一些常见题型","text":"数组篇通过工作中的几次教训, 终于领悟到题还是要刷滴, 整理出一些常见题型 1. 请使用PHP实现冒泡排序，将数组$a = array()按照从小到大的方式进行排序1234567891011121314151617181920/** * 冒泡排序 * @param array $arr 需要排序的数组 * @return array|false */function bubble_sorting( array $arr )&#123; $len = count($arr); // 最外层循环控制需要冒泡的轮数 for ( $i=1; $i &lt; $len; $i++ ) &#123; for ( $j=0; $j &lt; $len-$i; $j++ ) &#123; if ( $arr[$j] &gt; $arr[$j+1] ) &#123; $tmp = $arr[$j+1]; $arr[$j+1] = $arr[$j]; $arr[$j] = $tmp; &#125; &#125; &#125; return $arr;&#125; 2.创建一个长度为10的数组, 数组中的元素为递增的奇数, 首项为112345678910111213/** * 创建一个元素递增为奇数的数组 * @param int $first 第一个元素的值 * @param int $length 数组长度 */function element_odd_number_arr(int $first=1, int $length=10)&#123; $arr = []; for ( $i=0; $i &lt; $length; $i++ ) &#123; $arr[] = ($i+$first) * 2 - 1; &#125; return $arr;&#125; 3.求出数组中最大下标1234567891011121314151617181920/** * 得出数组中最大值的下标 * @param array $arr * @return mixed */function max_key(array $arr)&#123; $maxKey = false; foreach ( $arr as $key =&gt; $item ) &#123; if ( !isset($maxVal) ) &#123; $maxVal = $item; $maxKey = $key; continue; &#125; if ( $maxVal &lt; $item ) &#123; $maxKey = $key; &#125; &#125; return $maxKey;&#125; 4.创建一个指定长度的数组, 数组中的元素满足斐波拉契数列的规律斐波拉契数列又称黄金分割数, 如下的定义方法: F0=0, F1=1, Fn=F(n-1)+F(n-2)（n&gt;=2，n∈N*） 1234567891011121314151617/** * 创建一个元素满足斐波拉契数列规律的数组 * @param int $length 数组长度 * @return array */function golden_section_arr(int $length=10)&#123; $result = []; for ( $i = 0; $i &lt; $length; $i++ ) &#123; if ( $i &lt; 2 ) &#123; $result[$i] = $i; continue; &#125; $result[$i] = $result[$i-1] + $result[$i-2]; &#125; return $result;&#125; 5.计算数组中最大数和最小数的差12345678910/** * 计算数组中的最大数和最小数的差值 * @param array $arr * @return int */function diff_val(array $arr)&#123; sort($arr); return end($arr)-reset($arr);&#125; 6.截取数组元素后几位拼接到数组前,顺序不变1234567891011121314151617/** * 截取数组元素后几位拼接到数组前 * @param array $arr * @param int $length 要截取的位数 * @return array|false */function cut_splice_arr(array $arr, int $length=1)&#123; $count = count($arr); if ( $count &lt; $length ) &#123; return false; &#125; $front = array_slice($arr, 0, $count-$length, true); $after = array_slice($arr, $count-$length, $length, true); return array_merge($after, $front);&#125; 7.不使用函数,将两个数组组成一个数组12345678910111213/** * 将两个数组组成一个数组 * @param array $arr1 * @param array $arr2 * @return array */function recombinate_array(array $arr1, array $arr2)&#123; foreach ( $arr1 as $_item ) &#123; $arr2[] = $_item; &#125; return $arr2;&#125; 8.数组逆序(不能使用rsort函数, 不能生成新的数组)123456789101112131415161718192021222324252627/** * 数组逆序 * @param array $arr * @return array */function reverse_order_arr(array $arr)&#123; $i = &quot;&quot;; // 要替换位置的数的下标 $j = &quot;&quot;; // 临时变量 $k = &quot;&quot;; // 被替换位置的数的下标 $len = count($arr); $half_len = floor($len/2); // 向下取整,取整的值是循环的次数 for( $i=0; $i&lt;$half_len; $i++ ) &#123; $j = $arr[$i]; // 判断数组个数奇偶 if ( $len % 2 !== 0 ) &#123; $k = $half_len*2-$i; &#125; else &#123; $k = $half_len*2-$i-1; &#125; $arr[$i] = $arr[$k]; $arr[$k] = $j; &#125; return $arr;&#125; 9.快速排序1234567891011121314151617181920212223/** * 数组快速排序 * @param array $arr * @return array */function quick_sort(array $arr)&#123; $count = count($arr); if ( $count &lt;= 1 ) return $arr; $key = $arr[0]; $left_arr = []; $right_arr = []; for ( $i=1; $i&lt;$count; $i++ ) &#123; if ( $arr[$i] &lt;= $key ) &#123; $left_arr[] = $arr[$i]; &#125; else &#123; $right_arr[] = $arr[$i]; &#125; &#125; $left_arr = quick_sort($left_arr); $right_arr = quick_sort($right_arr); return array_merge($left_arr, [$key], $right_arr);&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"},{"name":"数组","slug":"数组","permalink":"https://zhuxv.github.io/tags/%E6%95%B0%E7%BB%84/"}],"author":"Zhu Xv"}],"categories":[{"name":"REDIS","slug":"REDIS","permalink":"https://zhuxv.github.io/categories/REDIS/"},{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/categories/MySQL/"},{"name":"系统","slug":"系统","permalink":"https://zhuxv.github.io/categories/%E7%B3%BB%E7%BB%9F/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"REDIS","slug":"REDIS","permalink":"https://zhuxv.github.io/tags/REDIS/"},{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/tags/MySQL/"},{"name":"系统","slug":"系统","permalink":"https://zhuxv.github.io/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"},{"name":"字符串","slug":"字符串","permalink":"https://zhuxv.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数组","slug":"数组","permalink":"https://zhuxv.github.io/tags/%E6%95%B0%E7%BB%84/"}]}