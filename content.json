{"meta":{"title":"小朱的技术博客","subtitle":"","description":"","author":"Zhu Xv","url":"https://zhuxv.github.io","root":"/"},"pages":[{"title":"about","date":"2020-09-24T05:17:40.000Z","updated":"2020-09-24T05:17:40.653Z","comments":true,"path":"about/index.html","permalink":"https://zhuxv.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"PHP练习题-MySQL篇","slug":"PHP练习题-MySQL篇","date":"2020-09-25T06:17:43.000Z","updated":"2020-09-25T10:21:17.918Z","comments":true,"path":"2020/09/25/PHP练习题-MySQL篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/25/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-MySQL%E7%AF%87/","excerpt":"MySQL篇","text":"MySQL篇 1.MySQL的复制原理及其流程:1.主[binlog线程] 记录下所有改变了数据库数据的语句, 放进 master 上的 binlog 中 2.从[io线程] 在使用 start slave 之后, 负责从 master 上拉取 binlog 内容, 放进自己的 relay log 中 3.从[sql执行线程] 执行 relay log 中的语句 2.MySQL中MyISAM与InnoDB的区别:1 五点不同 (1) InnoDB支持事务, MyISAN不支持事务 (2) InnoDB支持行级锁, MyISAN支持表级锁 (3) InnoDB支持多版本并发控制(MVCC), MyISAN不支持MVCC (4) InnoDB支持外键, MyISAN不支持外键 (5) InnoDB不支持全文索引, 而MyISAN不支持索引 2 InnoDB引擎的4大特征 (1) [插入缓冲(insert buffer)](https://blog.csdn.net/dbanote/article/details/9077113) (2) [二次写(double write)](https://blog.csdn.net/dbanote/article/details/9078091) (3) [自适应哈希索引(ahi)](https://blog.csdn.net/dbanote/article/details/9078129) (4) [预读(read ahead)](https://blog.csdn.net/qq9808/article/details/105846413) 3 MyISAN和InnoDB统计哪个更快 MyISAN更快, 因为MyISAN内部维护了一个计数器 4 MyISAN和InnoDB的选择 (1) 需要支持事务,行级锁,外键选择InnoDB (2) 如果表中没有大量的新增删除修改,对原子性要求低,那么MyISAN是最好的选择(更建议使用nosql) (3) 系统崩溃后MyISAM恢复起来更困难 (4) 高并发建议使用InnoDB 3.MySQL中varchar与char的区别以及varchar(50)中的50代表的含义:1.char是一种固定长度的类型, varchar则是一种可变长度类型 2.varchar(50)中50的含义最多存放50个字符, varchar(50)和varchar(200)存储相同字符串所占空间一样,但是后者在排序时会消耗更多内存, 因为 order by col 采用 fixed_length 长度计算 col 长度(memory引擎也一样) 4.InnoDB事务与日志的实现方式1.有多少种日志 (1) 错误日志: 记录出错信息, 也记录一些警告和正确信息 (2) 查询日志: 记录所有对数据库请求的信息, 不论这些请求是否得到了正确的执行 (3) 慢查询日志: 设置一个阈值, 将运行时间超过该值的查询语句记录到日志中 (4) 二进制日志: 记录对数据库执行更改的所有操作 (5) 中继日志 (6) 事务日志 2.事务的4种隔离级别 (1) 读未提交(RU) (2) 读已提交(RC) (3) 可重复度(RR) (4) 串行 3.事务是如何通过日志来实现的 事务日志是通过 redio 和 innodb 的存储引擎日志缓冲 (Innodb log buffer) 来实现的, 当开始一个事务的时候, 会记录该事物的 isn(log sequence number)号; 当事务执行时, 会往 InnoDB 存储引擎日志的日志缓存里面插入事务; 当事务提交时, 必须将存储引擎的日志缓冲写入磁盘 (通过 innodb_flush_log_at_trx_commit 来控制), 也就是写数据前, 需要先写日志. 这种方式称为 &quot;预写日志方式&quot; 5.MySQL binlog的几种日志录入格式以及区别1.Statement: 每一条会修改数据的 sql 都会记录在 binlog 中 优点: 不需要记录每一行的变化, 减少了 binlog 的日志量, 节约了 IO, 提高了性能 缺点: 由于记录的只是执行语句, 为了这些语句能在 slave 上正确运行, 因此还必须记录每条语句在执行的时候的一些相关信息, 以保证所有语句能在 slave 得到和在 master 端执行时候的相同结果. 另外 mysql 的复制, 像一些特定函数功能, slave 可与 master 上要保持一致会有很多先关问题,比如使用一些函数将会出现一些问题或无法复制的现象 2. Row: 不记录 sql 语句上下文相关信息, 仅保存哪条记录被修改 优点: binlog 中不记录执行 sql 相关上下文信息, 仅需要记录哪一条记录被修改成什么了.所以 rowlevel 的日志内容会非常清楚的记录下每一行的数据修改的细节. 而且不会出现某些特定情况下的存储过程或 function 以及 trigger 的调用和触发无法被正确复制的问题 缺点: 所有的执行语句当记录到日志中的时候, 都将以每行记录的修改来记录, 这样会产生大量的日志内容 3. MixedLevel: 是以上两种级别的混合使用, 一般的语句修改使用 statement 格式保存 binlog, 如一些函数, statement 无法完成主从复制的操作, 则采用 row 格式保存 binlog, MySQL 会根据执行的每一条具体的 sql 语句来区分对待记录的日志形式, 也就是在 Statement 和 Row 之间选择一种, 新版本的 MySQL 中对 row level 模式也被做了优化, 并不是所有的修改都会以 row level 来记录, 像遇到表结构变更的时候就会以 statement 模式来记录. 至于 update 或者 delete 等修改数据的语句, 还是会记录所有行的变更 6.MySQL数据库CPU飙升到500%如何处理1. 列出所有进程 show processlist 观察所有进程, 多秒没有状态变化的 kill 掉 2. 查看超时日志或者错误日志, 一般会是查询以及大批量的插入会导致 CPU 与 I/O 上涨 7.sql优化1. 避免全文扫描, 首先考虑在 where 及 order by 上建立索引 2. 避免在 where 子句中对字段进行 null 判断, 避免使用 != &lt;&gt; 操作符, 避免使用 or 查询 3. in 和 not in 也要慎重使用, 很多时候使用 exists 代替 in 是一个很好的选择 4. 使用 like 时禁止左边模糊查询 5. 在 where 子句中避免对字段进行表达式操作 示例: where num/2=100 应改为 where num=100*2 6. 不要在 where 子句中的等于号 &quot;=&quot; 左边进行函数,算术表达式及其他表达式运算 7. 在使用索引字段作为条件时, 如果该索引是复合索引, 那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引, 否则该索引将不会被使用, 并且应尽可能的让字段顺序与索引顺序保持一致 8. 如果有大量重复数据时,这个字段应该避免建立索引 9. 索引可以提高查询效率, 但同样也可以降低插入和编辑效率, 所以要适量建立索引,一张表最好不超过6个索引 10. 尽量使用数字型字段, 字符型字段会降低查询和连接的性能, 并增加存储开销 11. 尽量使用 varchar 代替 char, 可以节约存储空间, 在一个相对较小的字段内搜索效率显然会更高一些 12. 查询时应该用具体字段代替 * 查询 13. 避免频繁创建临时表和删除临时表, 以减少系统表资源的消耗 14. 临时表并不是不可以使用, 当需要重复引用大型表或常用表中的某个数据集时 15. 在新建临时表时, 如果一次性插入数据量过大, 那么可以使用 select into 代替 create table, 避免造成大量log. 如果数据量不大, 为了缓和表的资源, 应先使用 create table, 然后 insert 16. 如果使用到了临时表, 在存储过程的最后务必将所有的临时表显式删除, 先 truncate table, 然后 drop table, 这样可以避免系统表较长时间锁定 17. 尽量避免使用游标查询, 因为游标查询效率太差, 如果有游标操作的数据超过 1万 行, 那么应该考虑改写 18. 使用游标或者临时表方法之前, 应先寻找基于集的解决方案来解决问题, 基于集的方法通常更有效 19. 尽量避免大事务操作, 提高系统并发能力 20. 尽量避免向客户返回大量数据, 若数据量过大, 应该考虑相应需求是否合理 8.InnoDB的读写参数优化1. innodb_buffer_poor_size: 用于缓冲数据和索引, 对于mysql的性能升级是线性的, 通常对于独立的 MySQL 服务器, innodb_buffer_poor_size最大可设置为内存大小的 70%-80% 计算方法: val = Innodb_buffer_pool_pages_data / Innodb_buffer_pool_pages_total * 100% val &gt; 95% 则考虑增大 innodb_buffer_pool_size， 建议使用物理内存的75% val &lt; 95% 则考虑减小 innodb_buffer_pool_size， 建议设置为：Innodb_buffer_pool_pages_data * Innodb_page_size * 1.05 / (1024*1024*1024) 2. 开启慢查询日志 slow.log, 增加参数: log_queries_not_using_indexes, 所有没有走索引的 sql 语句都会记录到 slow.log 中 3. 提高 query_cache 的命中率 命中率计算方法: Qcache_hits/(Qcache_hits + Qcache_inserts) * 100% 提高 qcache 命中率的方法: 数据动静分离 操作频繁的表和操作不频繁的表分开存放, 数据频繁更改会导致 query_cache 失效 单条 sql 语句的 query_cache 大小是有限制的, 当一条 sql 语句返回的数据大小超过 query_cache_limit 的值时不会缓存,可以适量增加 query_cache_limit 的值. query_cache_size 表示所有 query_cache 的总大小. 当整个数据库的 query_cache 大小超过该值, sql 语句也无法缓存 4. 高并发的情况下建议关闭 query_cache, 不然会有很多的 qcache 锁等待 9.你们的数据库是否支持emoji表情, 如果不支持, 应该怎么做如果是 UTF-8 字符集的话升级至 utf8-mb4 即可 10.表中有大字段x(例如: text类型),且字段x不会经常更新,已读为主,你会选择拆成子表还是放在一起,理由?拆开带来的问题: 连接消耗+存储拆分空间 不拆带来的问题: 查询性能 如果能容忍拆分带来的空间问题: 拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区)顺序IO,减少连接消耗, 最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗 如果能容忍不拆分带来的查询性能损失的话: 上面的方案在某个极致条件下肯定会出现问题, 那么不拆是最好的选择 参考博文[1] 【MySQL】20个经典面试题[2] sql优化的几种方式[3] 关于mysql innodb引擎性能优化的一点心得","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/tags/MySQL/"},{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"}],"author":"Zhu Xv"},{"title":"apache与nginx的区别","slug":"apache与nginx的区别","date":"2020-09-25T02:06:57.000Z","updated":"2020-09-25T09:15:40.159Z","comments":true,"path":"2020/09/25/apache与nginx的区别/","link":"","permalink":"https://zhuxv.github.io/2020/09/25/apache%E4%B8%8Enginx%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"apache与nginx的区别记录一下apache与nginx的区别, 以便在工作中可以正确选择","text":"apache与nginx的区别记录一下apache与nginx的区别, 以便在工作中可以正确选择 Nginx:1.轻量级, 采用C编写, 同样的web服务, 会占用更少的内存及资源 2.抗并发, 处理请求是异步非阻塞的, 负载能力比 apache 高很多, 而 apache 则是阻塞型的. 在高并发下 nginx 能保持低资源低消耗高性能, 而 apache 在 PHP 处理慢或者前端压力很大的情况下, 很容易出现进程数飙升, 从而拒绝服务现象 3.nginx 处理静态文件好, 静态处理性能是 apache 的三倍以上 4.nginx 的设计高度模块化, 编写模块相对简单 5.nginx 配置简洁, 正则配置让很多事情变得简单, 而且改完配置能使用 nginx -t 测试配置有没有问题, apache 配置复杂, 重启之后发现配置错误,会很崩溃 6.nginx 作为负载均衡服务器, 支持 7 层负载均衡 7.nginx 本身就是一个反向代理服务器, 而且可以作为非常优秀的邮件代理服务器 8.启动特别容易, 并且可以做到 24 小时不断运行, 即使运行数月也不需要重新启动, 还能够不间断服务的情况下进行版本升级 9.社区活跃, 各种高性能模块出品迅速 Apache:1.apache 的 rewrite 比 nginx 强大, 在 rewrite 频繁的情况下, 用 apache 2.apache 发展到现在, 模块超多, 基本想到的都可以找到 3.apache 更为成熟, 少 BUG, nginx BUG 相对比较多 4.apache 非常稳定 5.apache 对 PHP 支持比较简单, nginx 需配合其他后端用 6.apache 在处理动态请求的时候有优势, nginx 在这方面是鸡肋, 一般动态请求要 apache 去做, nginx 适合反向和静态 7.apache 仍然是目前的主流, 拥有丰富的特性, 成熟的技术和开发社区 总结两者最核心的区别在于 apache 是同步多进程模型, 一个连接对应一个进程, 而 nginx 是异步的, 多连接可以对应一个进程一般来说, 需要性能的 web 服务, 用 nginx, 如果不需要性能只要求稳定的服务, 更考虑的是 apache, 后者各种功能模块实现的比前者好, 可配置项多更为通用的方案是, 前端 nginx 抗并发, 后端 apache 集群, 配合起来会更好 参考博文[1] Apache和Nginx的区别","categories":[{"name":"系统","slug":"系统","permalink":"https://zhuxv.github.io/categories/%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"系统","slug":"系统","permalink":"https://zhuxv.github.io/tags/%E7%B3%BB%E7%BB%9F/"}],"author":"Zhu Xv"},{"title":"PHP练习题-基础篇","slug":"PHP练习题-基础篇","date":"2020-09-25T02:00:23.000Z","updated":"2020-09-25T09:13:31.059Z","comments":true,"path":"2020/09/25/PHP练习题-基础篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/25/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"基础篇","text":"基础篇 1.PHP语言的一大优势是跨平台,什么是跨平台PHP运行环境可以在不同的操作系统(例如: windows, linux等)上配置, 不受操作系统的限制, 所以叫跨平台","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"}],"author":"Zhu Xv"},{"title":"PHP练习题-字符串篇","slug":"PHP练习题-字符串篇","date":"2020-09-24T08:47:53.000Z","updated":"2020-09-25T09:13:46.521Z","comments":true,"path":"2020/09/24/PHP练习题-字符串篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/24/PHP%E7%BB%83%E4%B9%A0%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/","excerpt":"字符串篇","text":"字符串篇 1.定义一个生成随机字符串的函数1234567891011121314/** * 生成随机字符串 * @param int $length 长度 * @return string */function generate_random_string(int $length=10)&#123; $chars = &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;; $randomString = &#x27;&#x27;; for ( $i=0; $i&lt;$length; $i++ ) &#123; $randomString .= $chars[rand(0, strlen($chars)-1)]; &#125; return $randomString;&#125; 2.不使用函数,写一个字符串反转的函数1234567891011121314/** * 字符串反转函数 * @param string $str * @return string */function str_inver( string $str )&#123; $newStr = &#x27;&#x27;; $m = strlen($str) - 1; for( $i=$m; $i&gt;=0; $i-- ) &#123; $newStr .= $str[$m]; &#125; return $newStr;&#125; 3.写一个函数,将字符串每几位用指定符号隔开1234567891011121314151617181920/** * 将字符串隔几位用指定符号隔开 * @param string $str * @param string $symbol * @param int $num 每隔几位隔开 * @return string */function separate( string $str, string $symbol=&#x27;,&#x27;, int $num=3)&#123; $newStr = &#x27;&#x27;; $length = strlen($str); // 获取字符串长度 $k = $length%$num; for( $i=0; $i&lt;$length; $i++ ) &#123; if ( $i%$num == $k &amp;&amp; $i != 0 ) &#123; $newStr .= $symbol; &#125; $newStr .= $str[$i]; &#125; return $newStr;&#125; 4.获取文件扩展名123456789101112/** * 获取文件扩展名 * @param string $url 文件路径 * @return string */function ext_name(string $url)&#123; if ( strstr($url, &#x27;?&#x27;) ) &#123; $url = explode(&#x27;?&#x27;, $url)[0]; &#125; return end(explode(&#x27;.&#x27;, $url));&#125; 5.写一个函数,计算出两个文件的相对路径123456789101112131415161718192021222324/** * 计算出两个文件的相对路径 * @param string $path1 * @param string $path2 * @return string */function relative_path( string $path1, string $path2 )&#123; // 获取两文件的目录 $path1 = trim(dirname($path1), &#x27;/&#x27;); $path2 = trim(dirname($path2), &#x27;/&#x27;); $path1Arr = explode(&#x27;/&#x27;, $path1); $path2Arr = explode(&#x27;/&#x27;, $path2); $num = max(count($path1Arr), count($path2Arr)); for( $i=0; $i&lt;$num; $i++ ) &#123; if ( $path1Arr[$i] !== $path2Arr[$i] ) &#123; break; &#125; unset($path1Arr[$i], $path2Arr[$i]); &#125; return str_repeat(&#x27;../&#x27;, count($path2Arr)).implode(&#x27;/&#x27;, $path1Arr);&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"},{"name":"字符串","slug":"字符串","permalink":"https://zhuxv.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Zhu Xv"},{"title":"PHP练习题-数组篇","slug":"PHP联系题-数组篇","date":"2020-09-24T02:55:38.000Z","updated":"2020-09-25T09:16:02.638Z","comments":true,"path":"2020/09/24/PHP联系题-数组篇/","link":"","permalink":"https://zhuxv.github.io/2020/09/24/PHP%E8%81%94%E7%B3%BB%E9%A2%98-%E6%95%B0%E7%BB%84%E7%AF%87/","excerpt":"数组篇通过工作中的几次教训, 终于领悟到题还是要刷滴, 整理出一些常见题型","text":"数组篇通过工作中的几次教训, 终于领悟到题还是要刷滴, 整理出一些常见题型 1. 请使用PHP实现冒泡排序，将数组$a = array()按照从小到大的方式进行排序1234567891011121314151617181920/** * 冒泡排序 * @param array $arr 需要排序的数组 * @return array|false */function bubble_sorting( array $arr )&#123; $len = count($arr); // 最外层循环控制需要冒泡的轮数 for ( $i=1; $i &lt; $len; $i++ ) &#123; for ( $j=0; $j &lt; $len-$i; $j++ ) &#123; if ( $arr[$j] &gt; $arr[$j+1] ) &#123; $tmp = $arr[$j+1]; $arr[$j+1] = $arr[$j]; $arr[$j] = $tmp; &#125; &#125; &#125; return $arr;&#125; 2.创建一个长度为10的数组, 数组中的元素为递增的奇数, 首项为112345678910111213/** * 创建一个元素递增为奇数的数组 * @param int $first 第一个元素的值 * @param int $length 数组长度 */function element_odd_number_arr(int $first=1, int $length=10)&#123; $arr = []; for ( $i=0; $i &lt; $length; $i++ ) &#123; $arr[] = ($i+$first) * 2 - 1; &#125; return $arr;&#125; 3.求出数组中最大下标1234567891011121314151617181920/** * 得出数组中最大值的下标 * @param array $arr * @return mixed */function max_key(array $arr)&#123; $maxKey = false; foreach ( $arr as $key =&gt; $item ) &#123; if ( !isset($maxVal) ) &#123; $maxVal = $item; $maxKey = $key; continue; &#125; if ( $maxVal &lt; $item ) &#123; $maxKey = $key; &#125; &#125; return $maxKey;&#125; 4.创建一个指定长度的数组, 数组中的元素满足斐波拉契数列的规律斐波拉契数列又称黄金分割数, 如下的定义方法: F0=0, F1=1, Fn=F(n-1)+F(n-2)（n&gt;=2，n∈N*） 1234567891011121314151617/** * 创建一个元素满足斐波拉契数列规律的数组 * @param int $length 数组长度 * @return array */function golden_section_arr(int $length=10)&#123; $result = []; for ( $i = 0; $i &lt; $length; $i++ ) &#123; if ( $i &lt; 2 ) &#123; $result[$i] = $i; continue; &#125; $result[$i] = $result[$i-1] + $result[$i-2]; &#125; return $result;&#125; 5.计算数组中最大数和最小数的差12345678910/** * 计算数组中的最大数和最小数的差值 * @param array $arr * @return int */function diff_val(array $arr)&#123; sort($arr); return end($arr)-reset($arr);&#125; 6.截取数组元素后几位拼接到数组前,顺序不变1234567891011121314151617/** * 截取数组元素后几位拼接到数组前 * @param array $arr * @param int $length 要截取的位数 * @return array|false */function cut_splice_arr(array $arr, int $length=1)&#123; $count = count($arr); if ( $count &lt; $length ) &#123; return false; &#125; $front = array_slice($arr, 0, $count-$length, true); $after = array_slice($arr, $count-$length, $length, true); return array_merge($after, $front);&#125; 7.不使用函数,将两个数组组成一个数组12345678910111213/** * 将两个数组组成一个数组 * @param array $arr1 * @param array $arr2 * @return array */function recombinate_array(array $arr1, array $arr2)&#123; foreach ( $arr1 as $_item ) &#123; $arr2[] = $_item; &#125; return $arr2;&#125; 8.数组逆序(不能使用rsort函数, 不能生成新的数组)123456789101112131415161718192021222324252627/** * 数组逆序 * @param array $arr * @return array */function reverse_order_arr(array $arr)&#123; $i = &quot;&quot;; // 要替换位置的数的下标 $j = &quot;&quot;; // 临时变量 $k = &quot;&quot;; // 被替换位置的数的下标 $len = count($arr); $half_len = floor($len/2); // 向下取整,取整的值是循环的次数 for( $i=0; $i&lt;$half_len; $i++ ) &#123; $j = $arr[$i]; // 判断数组个数奇偶 if ( $len % 2 !== 0 ) &#123; $k = $half_len*2-$i; &#125; else &#123; $k = $half_len*2-$i-1; &#125; $arr[$i] = $arr[$k]; $arr[$k] = $j; &#125; return $arr;&#125; 9.快速排序1234567891011121314151617181920212223/** * 数组快速排序 * @param array $arr * @return array */function quick_sort(array $arr)&#123; $count = count($arr); if ( $count &lt;= 1 ) return $arr; $key = $arr[0]; $left_arr = []; $right_arr = []; for ( $i=1; $i&lt;$count; $i++ ) &#123; if ( $arr[$i] &lt;= $key ) &#123; $left_arr[] = $arr[$i]; &#125; else &#123; $right_arr[] = $arr[$i]; &#125; &#125; $left_arr = quick_sort($left_arr); $right_arr = quick_sort($right_arr); return array_merge($left_arr, [$key], $right_arr);&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"},{"name":"数组","slug":"数组","permalink":"https://zhuxv.github.io/tags/%E6%95%B0%E7%BB%84/"}],"author":"Zhu Xv"}],"categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/categories/MySQL/"},{"name":"系统","slug":"系统","permalink":"https://zhuxv.github.io/categories/%E7%B3%BB%E7%BB%9F/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/categories/PHP/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://zhuxv.github.io/tags/MySQL/"},{"name":"练习题","slug":"练习题","permalink":"https://zhuxv.github.io/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"系统","slug":"系统","permalink":"https://zhuxv.github.io/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"PHP","slug":"PHP","permalink":"https://zhuxv.github.io/tags/PHP/"},{"name":"字符串","slug":"字符串","permalink":"https://zhuxv.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数组","slug":"数组","permalink":"https://zhuxv.github.io/tags/%E6%95%B0%E7%BB%84/"}]}